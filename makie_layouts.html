<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>Layouts - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="JuliaDataScience/style.css"/>
    <script src="/mousetrap.min.js"></script>
    <!-- TODO: Add url_prefix. -->
  <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <script src="https://cdn.usefathom.com/script.js" data-site="EEJXHKTE" defer></script>
<script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="eB2Isj56H4g6ndupKwaKyHau7lCkTsVV"></script>
<link rel="stylesheet" href="JuliaDataScience/github.min.css">
<script src="JuliaDataScience/highlight.min.js"></script>
<script src="JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="JuliaDataScience/preface"><b>1</b> Preface</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/why_data_science"><b>1.1</b> What is Data Science?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/engineering"><b>1.2</b> Software Engineering</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/acknowledgements"><b>1.3</b> Acknowledgements</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/why_julia"><b>2</b> Why Julia?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/non-programmers"><b>2.1</b> For Non-Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/programmers"><b>2.2</b> For Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_accomplish"><b>2.3</b> What Julia Aims to Accomplish?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_wild"><b>2.4</b> Julia in the Wild</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/julia_basics"><b>3</b> Julia Basics</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/ide"><b>3.1</b> Development Environments</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/syntax"><b>3.2</b> Language Syntax</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/data_structures"><b>3.3</b> Native Data Structures</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filesystem"><b>3.4</b> Filesystem</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/standardlibrary"><b>3.5</b> Julia Standard Library</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/load_save"><b>4.1</b> Load and Save Files</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/index-and-summarize"><b>4.2</b> Index and Summarize</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filter_subset"><b>4.3</b> Filter and Subset</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/missing_data"><b>4.5</b> Types and Missing Data</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/variable-transformations"><b>4.7</b> Variable Transformations</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/groupby_combine"><b>4.8</b> Groupby and Combine</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/df_performance"><b>4.9</b> Performance</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/DataVisualizationMakie"><b>5</b> Data Visualization with Makie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/datavisMakie_attributes"><b>5.2</b> Attributes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/themes"><b>5.3</b> Themes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/using-latexstrings.jl"><b>5.4</b> Using LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_colors"><b>5.5</b> Colors and Colormaps</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/appendix"><b>6</b> Appendix</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/appendix_pkg"><b>6.1</b> Packages Versions</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/notation"><b>6.2</b> Notation</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/references"><b></b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="5.6" id="sec:makie_layouts"><span class="header-section-number">5.6</span> Layouts</h2>
<p>A complete <em>canvas/layout</em> is defined by <code>Figure</code>, which can be filled with content after creation. We will start with a simple arrangement of one <code>Axis</code>, one <code>Legend</code> and one <code>Colorbar</code>. For this task we can think of the canvas as an arrangement of <code>rows</code> and <code>columns</code> in indexing a <code>Figure</code> much like a regular <code>Array</code>/<code>Matrix</code>. The <code>Axis</code> content will be in <em>row 1, column 1</em>, e.g. <code>fig[1, 1]</code>, the <code>Colorbar</code> in <em>row 1, column 2</em>, namely <code>fig[1, 2]</code>. And the <code>Legend</code> in <em>row 2</em> and across <em>column 1 and 2</em>, namely <code>fig[2, 1:2]</code>.</p>
<pre class="language-julia"><code>function first_layout()
    seed!(123)
    x, y, z = randn(6), randn(6), randn(6)
    fig = Figure(resolution=(600, 400), backgroundcolor=:grey90)
    ax = Axis(fig[1, 1], backgroundcolor=:white)
    pltobj = scatter!(ax, x, y; color=z, label=&quot;scatters&quot;)
    lines!(ax, x, 1.1y; label=&quot;line&quot;)
    Legend(fig[2, 1:2], ax, &quot;labels&quot;, orientation=:horizontal)
    Colorbar(fig[1, 2], pltobj, label=&quot;colorbar&quot;)
    fig
end
first_layout()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_first_layout_.svg" id="fig:first_layout" style="width:60.0%" alt="Figure 27: First Layout." /><figcaption aria-hidden="true">Figure 27: First Layout.</figcaption>
</figure>
<p>This does look good already, it could be better. We could fix spacing problems using the following keywords and methods:</p>
<ul>
<li><code>figure_padding=(left, right, bottom, top)</code></li>
<li><code>padding=(left, right, bottom, top)</code></li>
</ul>
<p>Taking into account the actual size for a <code>Legend</code> or <code>Colorbar</code> is done by</p>
<blockquote>
<ul>
<li><code>tellheight=true</code> or <code>false</code></li>
<li><code>tellwidth=true</code> or <code>false</code></li>
</ul>
<p><em>Setting these to <code>true</code> will take into account the actual size (height or width) for a <code>Legend</code> or <code>Colorbar</code></em>. Consequently, things will be resized accordingly.</p>
</blockquote>
<p>The space between columns and rows is specified as</p>
<blockquote>
<ul>
<li><code>colgap!(fig.layout, col, separation)</code></li>
<li><code>rowgap!(fig.layout, row, separation)</code></li>
</ul>
<p><em>Column gap</em> (<code>colgap!</code>), if <code>col</code> is given then the gap will be applied to that specific column. <em>Row gap</em> (<code>rowgap!</code>) ,if <code>row</code> is given then the gap will be applied to that specific row.</p>
</blockquote>
<p>Also, we will see how to put content into the <strong>protrusions</strong>, <em>i.e.</em> the space reserved for <em>title: <code>x</code> and <code>y</code>; either <code>ticks</code> or <code>label</code></em>. We do this by plotting into <code>fig[i, j, protrusion]</code> where <em><code>protrusion</code></em> can be <code>Left()</code>, <code>Right()</code>, <code>Bottom()</code> and <code>Top()</code>, or for each corner <code>TopLeft()</code>, <code>TopRight()</code>, <code>BottomRight()</code>, <code>BottomLeft()</code>. See below how these options are being used:</p>
<pre class="language-julia"><code>function first_layout_fixed()
    seed!(123)
    x, y, z = randn(6), randn(6), randn(6)
    fig = Figure(figure_padding=(0, 3, 5, 2), resolution=(600, 400),
        backgroundcolor=:grey90, font=&quot;CMU Serif&quot;)
    ax = Axis(fig[1, 1], xlabel=L&quot;x&quot;, ylabel=L&quot;y&quot;,
        title=&quot;Layout example&quot;, backgroundcolor=:white)
    pltobj = scatter!(ax, x, y; color=z, label=&quot;scatters&quot;)
    lines!(ax, x, 1.1y, label=&quot;line&quot;)
    Legend(fig[2, 1:2], ax, &quot;Labels&quot;, orientation=:horizontal,
        tellheight=true, titleposition=:left)
    Colorbar(fig[1, 2], pltobj, label=&quot;colorbar&quot;)
    # additional aesthetics
    Box(fig[1, 1, Right()], color=(:slateblue1, 0.35))
    Label(fig[1, 1, Right()], &quot;protrusion&quot;, textsize=18,
        rotation=pi / 2, padding=(3, 3, 3, 3))
    Label(fig[1, 1, TopLeft()], &quot;(a)&quot;, textsize=18, padding=(0, 3, 8, 0))
    colgap!(fig.layout, 5)
    rowgap!(fig.layout, 5)
    fig
end
first_layout_fixed()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_first_layout_fixed_.svg" id="fig:first_layout_fixed" style="width:60.0%" alt="Figure 28: First Layout Fixed." /><figcaption aria-hidden="true">Figure 28: First Layout Fixed.</figcaption>
</figure>
<p>Here, having the label <code>(a)</code> in the <code>TopLeft()</code> is probably not necessary, this will only make sense for more than two plots. For our next example let’s keep using the previous tools and some more to create a richer and complex figure.</p>
<p>You can hide decorations and axis’ spines with:</p>
<blockquote>
<ul>
<li><code>hidedecorations!(ax; kwargs...)</code></li>
<li><code>hidexdecorations!(ax; kwargs...)</code></li>
<li><code>hideydecorations!(ax; kwargs...)</code></li>
<li><code>hidespines!(ax; kwargs...)</code></li>
</ul>
</blockquote>
<p>Remember, we can always ask for help to see what kind of arguments we can use, e.g.,</p>
<pre class="language-julia"><code>help(hidespines!)</code></pre>
<pre class="output"><code>  hidespines!(la::Axis, spines::Symbol... = (:l, :r, :b, :t)...)

  Hide all specified axis spines. Hides all spines by default, otherwise
  choose with the symbols :l, :r, :b and :t.

  hidespines! has the following function signatures:

    (Vector, Vector)
    (Vector, Vector, Vector)
    (Matrix)

  Available attributes for Combined{Makie.MakieLayout.hidespines!, T} where T
  are:

  </code></pre>
<p>Alternatively, for decorations</p>
<pre class="language-julia"><code>help(hidedecorations!)</code></pre>
<pre class="output"><code>  hidedecorations!(la::Axis)

  Hide decorations of both x and y-axis: label, ticklabels, ticks and grid.

  hidedecorations! has the following function signatures:

    (Vector, Vector)
    (Vector, Vector, Vector)
    (Matrix)

  Available attributes for Combined{Makie.MakieLayout.hidedecorations!, T}
  where T are:

  </code></pre>
<p>For elements that <strong>you don’t want to hide</strong>, just pass them with <code>false</code>, i.e. <code>hideydecorations!(ax; ticks=false, grid=false)</code>.</p>
<p>Synchronizing your <code>Axis</code> is done via:</p>
<blockquote>
<ul>
<li><code>linkaxes!</code>, <code>linkyaxes!</code> and <code>linkxaxes!</code></li>
</ul>
<p>This could be useful when shared axis are desired. Another way of getting shared axis will be by setting <code>limits!</code>.</p>
</blockquote>
<p>Setting <code>limits</code> at once or independently for each axis is done by calling</p>
<blockquote>
<ul>
<li><code>limits!(ax; l, r, b, t)</code>, where <code>l</code> is left, <code>r</code> right, <code>b</code> bottom, and <code>t</code> top.</li>
</ul>
<p>You can also do <code>ylims!(low, high)</code> or <code>xlims!(low, high)</code>, and even open ones by doing <code>ylims!(low=0)</code> or <code>xlims!(high=1)</code>.</p>
</blockquote>
<p>Now, the example:</p>
<pre class="language-julia"><code>function complex_layout_double_axis()
    seed!(123)
    x = LinRange(0, 1, 10)
    y = LinRange(0, 1, 10)
    z = rand(10, 10)
    fig = Figure(resolution=(600, 400), font=&quot;CMU Serif&quot;, backgroundcolor=:grey90)
    ax1 = Axis(fig, xlabel=L&quot;x&quot;, ylabel=L&quot;y&quot;)
    ax2 = Axis(fig, xlabel=L&quot;x&quot;)
    heatmap!(ax1, x, y, z; colorrange=(0, 1))
    series!(ax2, abs.(z[1:4, :]); labels=[&quot;lab $i&quot; for i = 1:4], color=:Set1_4)
    hm = scatter!(10x, y; color=z[1, :], label=&quot;dots&quot;, colorrange=(0, 1))
    hideydecorations!(ax2, ticks=false, grid=false)
    linkyaxes!(ax1, ax2)
    #layout
    fig[1, 1] = ax1
    fig[1, 2] = ax2
    Label(fig[1, 1, TopLeft()], &quot;(a)&quot;, textsize=18, padding=(0, 6, 8, 0))
    Label(fig[1, 2, TopLeft()], &quot;(b)&quot;, textsize=18, padding=(0, 6, 8, 0))
    Colorbar(fig[2, 1:2], hm, label=&quot;colorbar&quot;, vertical=false, flipaxis=false)
    Legend(fig[1, 3], ax2, &quot;Legend&quot;)
    colgap!(fig.layout, 5)
    rowgap!(fig.layout, 5)
    fig
end
complex_layout_double_axis()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_complex_layout_double_axis_.svg" id="fig:complex_layout_double_axis" style="width:60.0%" alt="Figure 29: Complex layout double axis." /><figcaption aria-hidden="true">Figure 29: Complex layout double axis.</figcaption>
</figure>
<p>So, now our <code>Colorbar</code> needs to be horizontal and the bar ticks need to be in the lower part. This is done by setting <code>vertical=false</code> and <code>flipaxis=false</code>. Additionally, note that we can call many <code>Axis</code> into <code>fig</code>, or even <code>Colorbar</code>’s and <code>Legend</code>’s, and then afterwards build the layout.</p>
<p>Another common layout is a grid of squares for heatmaps:</p>
<pre class="language-julia"><code>function squares_layout()
    seed!(123)
    letters = reshape(collect(&#39;a&#39;:&#39;d&#39;), (2, 2))
    fig = Figure(resolution=(600, 400), fontsize=14, font=&quot;CMU Serif&quot;,
        backgroundcolor=:grey90)
    axs = [Axis(fig[i, j], aspect=DataAspect()) for i = 1:2, j = 1:2]
    hms = [heatmap!(axs[i, j], randn(10, 10), colorrange=(-2, 2))
           for i = 1:2, j = 1:2]
    Colorbar(fig[1:2, 3], hms[1], label=&quot;colorbar&quot;)
    [Label(fig[i, j, TopLeft()], &quot;($(letters[i, j]))&quot;, textsize=16,
        padding=(-2, 0, -20, 0)) for i = 1:2, j = 1:2]
    colgap!(fig.layout, 5)
    rowgap!(fig.layout, 5)
    fig
end
squares_layout()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_squares_layout_.svg" id="fig:squares_layout" style="width:60.0%" alt="Figure 30: Squares layout." /><figcaption aria-hidden="true">Figure 30: Squares layout.</figcaption>
</figure>
<p>where all labels are in the <strong>protrusions</strong> and each <code>Axis</code> has an <code>AspectData()</code> ratio. The <code>Colorbar</code> is located in the third column and expands from row 1 up to row 2.</p>
<p>The next case uses the so called <code>Mixed()</code> <strong>alignmode</strong>, which is especially useful when dealing with large empty spaces between <code>Axis</code> due to long ticks. Also, the <code>Dates</code> module from Julia’s standard library will be needed it for this example.</p>
<pre><code>using Dates</code></pre>
<pre class="language-julia"><code>function mixed_mode_layout()
    seed!(123)
    longlabels = [&quot;$(today() - Day(1))&quot;, &quot;$(today())&quot;, &quot;$(today() + Day(1))&quot;]
    fig = Figure(resolution=(600, 400), fontsize=12,
        backgroundcolor=:grey90, font=&quot;CMU Serif&quot;)
    ax1 = Axis(fig[1, 1])
    ax2 = Axis(fig[1, 2], xticklabelrotation=pi / 2, alignmode=Mixed(bottom=0),
        xticks=([1, 5, 10], longlabels))
    ax3 = Axis(fig[2, 1:2])
    ax4 = Axis(fig[3, 1:2])
    axs = [ax1, ax2, ax3, ax4]
    [lines!(ax, 1:10, rand(10)) for ax in axs]
    hidexdecorations!(ax3; ticks=false, grid=false)
    Box(fig[2:3, 1:2, Right()], color=(:slateblue1, 0.35))
    Label(fig[2:3, 1:2, Right()], &quot;protrusion&quot;, rotation=pi / 2, textsize=14,
        padding=(3, 3, 3, 3))
    Label(fig[1, 1:2, Top()], &quot;Mixed alignmode&quot;, textsize=16,
        padding=(0, 0, 15, 0))
    colsize!(fig.layout, 1, Auto(2))
    rowsize!(fig.layout, 2, Auto(0.5))
    rowsize!(fig.layout, 3, Auto(0.5))
    rowgap!(fig.layout, 1, 15)
    rowgap!(fig.layout, 2, 0)
    colgap!(fig.layout, 5)
    fig
end
mixed_mode_layout()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_mixed_mode_layout_.svg" id="fig:mixed_mode_layout" style="width:60.0%" alt="Figure 31: Mixed mode layout." /><figcaption aria-hidden="true">Figure 31: Mixed mode layout.</figcaption>
</figure>
<p>Here, the argument <code>alignmode=Mixed(bottom=0)</code> is shifting the bounding box to the bottom, so that this will align with the panel on the left filling the space.</p>
<p>Also, see how <code>colsize!</code> and <code>rowsize!</code> are being used for different columns and rows. You could also put a number instead of <code>Auto()</code> but then everything will be fixed. And, additionally, one could also give a <code>height</code> or <code>width</code> when defining the <code>Axis</code>, as in <code>Axis(fig, heigth=50)</code> which will be fixed as well.</p>
<h3 data-number="5.6.1" id="nested-axis-subplots"><span class="header-section-number">5.6.1</span> Nested <code>Axis</code> (<em>subplots</em>)</h3>
<p>It is also possible to define a set of <code>Axis</code> (<em>subplots</em>) explicitly, and use it to build a main figure with several rows and columns. For instance, the following its a “complicated” arrangement of <code>Axis</code>:</p>
<pre class="language-julia"><code>function nested_sub_plot!(fig)
    color = rand(RGBf0)
    ax1 = Axis(fig[1, 1], backgroundcolor=(color, 0.25))
    ax2 = Axis(fig[1, 2], backgroundcolor=(color, 0.25))
    ax3 = Axis(fig[2, 1:2], backgroundcolor=(color, 0.25))
    ax4 = Axis(fig[1:2, 3], backgroundcolor=(color, 0.25))
    return (ax1, ax2, ax3, ax4)
end</code></pre>
<p>which, when used to build a more complex figure by doing several calls, we obtain:</p>
<pre class="language-julia"><code>function main_figure()
    fig = Figure()
    Axis(fig[1, 1])
    nested_sub_plot!(fig[1, 2])
    nested_sub_plot!(fig[1, 3])
    nested_sub_plot!(fig[2, 1:3])
    fig
end
main_figure()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_main_figure_.svg" id="fig:main_figure" style="width:60.0%" alt="Figure 32: Main figure." /><figcaption aria-hidden="true">Figure 32: Main figure.</figcaption>
</figure>
<p>Note that different subplot functions can be called here. Also, each <code>Axis</code> here is an independent part of <code>Figure</code>. So that, if you need to do some <code>rowgap!</code>’s or <code>colsize!</code>’s operations, you will need to do it in each one of them independently or to all of them together.</p>
<p>For grouped <code>Axis</code> (<em>subplots</em>) we can use <code>GridLayout()</code> which, then, could be used to composed a more complicated <code>Figure</code>.</p>
<h3 data-number="5.6.2" id="nested-gridlayout"><span class="header-section-number">5.6.2</span> Nested GridLayout</h3>
<p>By using <code>GridLayout()</code> we can group subplots, allowing more freedom to build complex figures. Here, using our previous <code>nested_sub_plot!</code> we define three sub-groups and one normal <code>Axis</code>:</p>
<pre class="language-julia"><code>function nested_Grid_Layouts()
    fig = Figure(backgroundcolor=RGBf0(0.96, 0.96, 0.96))
    ga = fig[1, 1] = GridLayout()
    gb = fig[1, 2] = GridLayout()
    gc = fig[1, 3] = GridLayout()
    gd = fig[2, 1:3] = GridLayout()
    gA = Axis(ga[1, 1])
    nested_sub_plot!(gb)
    axsc = nested_sub_plot!(gc)
    nested_sub_plot!(gd)
    [hidedecorations!(axsc[i], grid=false, ticks=false) for i = 1:length(axsc)]
    colgap!(gc, 5)
    rowgap!(gc, 5)
    rowsize!(fig.layout, 2, Auto(0.5))
    colsize!(fig.layout, 1, Auto(0.5))
    fig
end
nested_Grid_Layouts()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_nested_Grid_Layouts_.svg" id="fig:nested_Grid_Layouts" style="width:60.0%" alt="Figure 33: Nested Grid Layouts." /><figcaption aria-hidden="true">Figure 33: Nested Grid Layouts.</figcaption>
</figure>
<p>Now, using <code>rowgap!</code> or <code>colsize!</code> over each group is possible and <code>rowsize!, colsize!</code> can also be applied to the set of <code>GridLayout()</code>s.</p>
<h3 data-number="5.6.3" id="inset-plots"><span class="header-section-number">5.6.3</span> Inset plots</h3>
<p>Currently, doing <code>inset</code> plots is a little bit tricky. Here, we show two possible ways of doing it by initially defining auxiliary functions. The first one is by doing a <code>BBox</code>, which lives in the whole <code>Figure</code> space:</p>
<pre class="language-julia"><code>function add_box_inset(fig; left=100, right=250, bottom=200, top=300,
    bgcolor=:grey90)
    inset_box = Axis(fig, bbox=BBox(left, right, bottom, top),
        xticklabelsize=12, yticklabelsize=12, backgroundcolor=bgcolor)
    # bring content upfront
    translate!(inset_box.scene, 0, 0, 10)
    elements = keys(inset_box.elements)
    filtered = filter(ele -&gt; ele != :xaxis &amp;&amp; ele != :yaxis, elements)
    foreach(ele -&gt; translate!(inset_box.elements[ele], 0, 0, 9), filtered)
    return inset_box
end</code></pre>
<p>Then, the <code>inset</code> is easily done, as in:</p>
<pre class="language-julia"><code>function figure_box_inset()
    fig = Figure(resolution=(600, 400))
    ax = Axis(fig[1, 1], backgroundcolor=:white)
    inset_ax1 = add_box_inset(fig; left=100, right=250, bottom=200, top=300,
        bgcolor=:grey90)
    inset_ax2 = add_box_inset(fig; left=500, right=600, bottom=100, top=200,
        bgcolor=(:white, 0.65))
    lines!(ax, 1:10)
    lines!(inset_ax1, 1:10)
    scatter!(inset_ax2, 1:10, color=:black)
    fig
end
figure_box_inset()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_figure_box_inset_.svg" id="fig:figure_box_inset" style="width:60.0%" alt="Figure 34: Figure box inset." /><figcaption aria-hidden="true">Figure 34: Figure box inset.</figcaption>
</figure>
<p>where the <code>Box</code> dimensions are bound by the <code>Figure</code>’s <code>resolution</code>. Note, that an inset can be also outside the <code>Axis</code>. The other approach, is by defining a new <code>Axis</code> into a position <code>fig[i, j]</code> specifying his <code>width</code>, <code>height</code>, <code>halign</code> and <code>valign</code>. We do that in the following function:</p>
<pre class="language-julia"><code>function add_axis_inset(; pos=fig[1, 1], halign=0.1, valign=0.5,
    width=Relative(0.5), height=Relative(0.35), bgcolor=:lightgray)
    inset_box = Axis(pos, width=width, height=height,
        halign=halign, valign=valign, xticklabelsize=12, yticklabelsize=12,
        backgroundcolor=bgcolor)
    # bring content upfront
    translate!(inset_box.scene, 0, 0, 10)
    elements = keys(inset_box.elements)
    filtered = filter(ele -&gt; ele != :xaxis &amp;&amp; ele != :yaxis, elements)
    foreach(ele -&gt; translate!(inset_box.elements[ele], 0, 0, 9), filtered)
    return inset_box
end</code></pre>
<p>See that in the following example the <code>Axis</code> with gray background will be rescaled if the total figure size changes. The <em>insets</em> are bound by the <code>Axis</code> positioning.</p>
<pre class="language-julia"><code>function figure_axis_inset()
    fig = Figure(resolution=(600, 400))
    ax = Axis(fig[1, 1], backgroundcolor=:white)
    inset_ax1 = add_axis_inset(; pos=fig[1, 1], halign=0.1, valign=0.65,
        width=Relative(0.3), height=Relative(0.3), bgcolor=:grey90)
    inset_ax2 = add_axis_inset(; pos=fig[1, 1], halign=1, valign=0.25,
        width=Relative(0.25), height=Relative(0.3), bgcolor=(:white, 0.65))
    lines!(ax, 1:10)
    lines!(inset_ax1, 1:10)
    scatter!(inset_ax2, 1:10, color=:black)
    fig
end
figure_axis_inset()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_figure_axis_inset_.svg" id="fig:figure_axis_inset" style="width:60.0%" alt="Figure 35: Figure axis inset." /><figcaption aria-hidden="true">Figure 35: Figure axis inset.</figcaption>
</figure>
<p>And this should cover most used cases for layouting with Makie. Now, let’s do some nice 3D examples with <code>GLMakie.jl</code>.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="JuliaDataScience/makie_colors"><b>5.5</b> Colors and Colormaps</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>