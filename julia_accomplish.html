<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>What Julia Aims to Accomplish? - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="JuliaDataScience/style.css"/>
    <script src="/mousetrap.min.js"></script>
    <!-- TODO: Add url_prefix. -->
  <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <script src="https://cdn.usefathom.com/script.js" data-site="EEJXHKTE" defer></script>
<script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="eB2Isj56H4g6ndupKwaKyHau7lCkTsVV"></script>
<link rel="stylesheet" href="JuliaDataScience/github.min.css">
<script src="JuliaDataScience/highlight.min.js"></script>
<script src="JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="JuliaDataScience/preface"><b>1</b> Preface</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/why_data_science"><b>1.1</b> What is Data Science?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/engineering"><b>1.2</b> Software Engineering</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/acknowledgements"><b>1.3</b> Acknowledgements</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/why_julia"><b>2</b> Why Julia?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/non-programmers"><b>2.1</b> For Non-Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/programmers"><b>2.2</b> For Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_accomplish"><b>2.3</b> What Julia Aims to Accomplish?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_wild"><b>2.4</b> Julia in the Wild</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/julia_basics"><b>3</b> Julia Basics</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/ide"><b>3.1</b> Development Environments</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/syntax"><b>3.2</b> Language Syntax</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/data_structures"><b>3.3</b> Native Data Structures</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filesystem"><b>3.4</b> Filesystem</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/standardlibrary"><b>3.5</b> Julia Standard Library</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/load_save"><b>4.1</b> Load and Save Files</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/index-and-summarize"><b>4.2</b> Index and Summarize</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filter_subset"><b>4.3</b> Filter and Subset</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/missing_data"><b>4.5</b> Types and Missing Data</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/variable-transformations"><b>4.7</b> Variable Transformations</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/groupby_combine"><b>4.8</b> Groupby and Combine</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/df_performance"><b>4.9</b> Performance</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/DataVisualizationMakie"><b>5</b> Data Visualization with Makie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/datavisMakie_attributes"><b>5.2</b> Attributes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/themes"><b>5.3</b> Themes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/using-latexstrings.jl"><b>5.4</b> Using LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_colors"><b>5.5</b> Colors and Colormaps</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/appendix"><b>6</b> Appendix</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/appendix_pkg"><b>6.1</b> Packages Versions</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/notation"><b>6.2</b> Notation</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/references"><b></b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="2.3" id="sec:julia_accomplish"><span class="header-section-number">2.3</span> What Julia Aims to Accomplish?</h2>
<blockquote>
<p><strong><em>NOTE:</em></strong> In this section we will explain the details of what makes Julia shine as a programming language. If it becomes too technical for you, you can skip and go straight to Section <a href="JuliaDataScience/dataframes#sec:dataframes">4</a> to learn about tabular data with <code>DataFrames.jl</code>.</p>
</blockquote>
<p>The Julia programming language <span class="citation" data-cites="bezanson2017julia">(<a href="JuliaDataScience/references#ref-bezanson2017julia" role="doc-biblioref">Bezanson et al., 2017</a>)</span> is a relatively new language, first released in 2012, and aims to be <strong>both easy and fast</strong>. It “runs like C<a href="JuliaDataScience#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> but reads like Python” <span class="citation" data-cites="perkelJuliaComeSyntax2019">(<a href="JuliaDataScience/references#ref-perkelJuliaComeSyntax2019" role="doc-biblioref">Perkel, 2019</a>)</span>. It was made for scientific computing, capable of handling <strong>large amounts of data and computation</strong> while still being fairly <strong>easy to manipulate, create, and prototype code</strong>.</p>
<p>The creators of Julia explained why they created Julia in a <a href="https://julialang.org/blog/2012/02/why-we-created-julia/">2012 blogpost</a>. They said:</p>
<blockquote>
<p>We are greedy: we want more. We want a language that’s open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that’s homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled.</p>
</blockquote>
<p>Most users are attracted to Julia because of the <strong>superior speed</strong>. After all, Julia is a member of a prestigious and exclusive club. The <a href="https://www.hpcwire.com/off-the-wire/julia-joins-petaflop-club/"><strong>petaflop club</strong></a> is comprised of languages who can exceed speeds of <strong>one petaflop<a href="JuliaDataScience#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> per second at peak performance</strong>. Currently only C, C++, Fortran, and Julia belong to the <a href="https://www.nextplatform.com/2017/11/28/julia-language-delivers-petascale-hpc-performance/">petaflop club</a>.</p>
<p>But, speed is not all that Julia can deliver. The <strong>ease of use</strong>, <strong>Unicode support</strong>, and a language that makes <strong>code sharing effortless</strong> are some of Julia’s features. We’ll address all those features in this section, but we want to focus on the Julia code sharing feature for now.</p>
<p>The Julia ecosystem of packages is something unique. It enables not only code sharing but also allows sharing of user-created types. For example, Python’s <code>pandas</code> uses its own <code>Datetime</code> type to handle dates. The same with R tidyverse’s <code>lubridate</code> package, which also defines its own <code>datetime</code> type to handle dates. Julia doesn’t need any of this, it has all the date stuff already baked into its standard library. This means that other packages don’t have to worry about dates. They just have to extend Julia’s <code>DateTime</code> type to new functionalities by defining new functions and do not need to define new types. Julia’s <code>Dates</code> module can do amazing stuff, but we are getting ahead of ourselves now. Let’s talk about some other features of Julia.</p>
<h3 data-number="2.3.1" id="julia-versus-other-programming-languages"><span class="header-section-number">2.3.1</span> Julia Versus Other Programming Languages</h3>
<p>In Figure <a href="JuliaDataScience#fig:language_comparison">2</a>, a highly opinionated representation is shown that divides the main open source and scientific computing languages in a 2x2 diagram with two axes: <strong>Slow-Fast</strong> and <strong>Easy-Hard</strong>. We’ve omitted closed source languages because there are many benefits to allowing other people to run your code for free as well as being able to inspect the source code in case of issues.</p>
<p>We’ve put C++ and FORTRAN in the hard and fast quadrant. Being static languages that need compilation, type checking, and other professional care and attention, they are really hard to learn and slow to prototype. The advantage is that they are <strong>really fast</strong> languages.</p>
<p>R and Python go into the easy and slow quadrant. They are dynamic languages that are not compiled and they execute in runtime. Because of this, they are really easy to learn and fast to prototype. Of course, this comes with a disadvantage: they are <strong>really slow</strong> languages.</p>
<p>Julia is the only language in the easy and fast quadrant. We don’t know any other serious language that would want to be hard and slow, so this quadrant is left empty.</p>
<figure>
<img src="images/language_comparisons.png" id="fig:language_comparison" alt="Figure 2: Scientific Computing Language Comparisons: logos for FORTRAN, C++, Python, R and Julia." /><figcaption aria-hidden="true">Figure 2: Scientific Computing Language Comparisons: logos for FORTRAN, C++, Python, R and Julia.</figcaption>
</figure>
<p><strong>Julia is fast! Very fast!</strong> It was designed for speed from the beginning. It accomplishes this by multiple dispatch. Basically, the idea is to generate very efficient LLVM<a href="JuliaDataScience#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> code. LLVM code, also known as LLVM instructions, are very low-level, that is, very close to the actual operations that your computer is executing. So, in essence, Julia converts your hand written and easy to read code to LLVM machine code which is very hard for humans to read, but easy for computers to read. For example, if you define a function taking one argument and pass an integer into the function, then Julia will create a <em>specialized</em> <code>MethodInstance</code>. The next time that you pass an integer to the function, Julia will look up the <code>MethodInstance</code> that was created earlier and refer execution to that. Now, the <strong>great</strong> trick is that you can also do this inside a function that calls a function. For example, if some data type is passed into function <code>f</code> and <code>f</code> calls function <code>g</code> and the data types passed to <code>g</code> are known and always the same, then the generated function <code>g</code> can be hardcoded into function <code>f</code>! This means that Julia doesn’t even have to lookup <code>MethodInstances</code> any more, and the code can run very efficiently. The trade-off, here, is that there are cases where earlier assumptions about the hardcoded <code>MethodInstances</code> are invalidated. Then, the <code>MethodInstance</code> has to be recreated which takes time. Also, the trade-off is that it takes time to infer what can be hardcoded and what not. This explains why it can often take very long before Julia does the first thing: in the background, it is optimizing your code.</p>
<p>The compiler in turns does what it does best: it optimizes machine code<a href="JuliaDataScience#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>. You can find <a href="https://julialang.org/benchmarks/">benchmarks</a> for Julia and several other languages here. Figure <a href="JuliaDataScience#fig:benchmarks">3</a> was taken from <a href="https://julialang.org/benchmarks/">Julia’s website benchmarks section<a href="JuliaDataScience#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></a>. As you can see Julia is <strong>indeed</strong> fast.</p>
<figure>
<img src="images/benchmarks.png" id="fig:benchmarks" alt="Figure 3: Julia versus other programming languages." /><figcaption aria-hidden="true">Figure 3: Julia versus other programming languages.</figcaption>
</figure>
<p>We really believe in Julia. Otherwise, we wouldn’t be writing this book. We think that Julia is the <strong>future of scientific computing and scientific data analysis</strong>. It enables the user to develop rapid and powerful code with a simple syntax. Usually, researchers develop code by prototyping using a very easy, but slow, language. Once the code is assured to run correctly and fulfill its goal, then begins the process of converting the code to a fast, but hard, language. This is known as the “Two-Language Problem” and we discuss next.</p>
<h3 data-number="2.3.2" id="sec:two_language"><span class="header-section-number">2.3.2</span> The Two-Language Problem</h3>
<p>The “Two-Language Problem” is a very typical situation in scientific computing where a researcher devises an algorithm or a solution to tackle a desired problem or analysis at hand. Then, the solution is prototyped in an easy to code language (like Python or R). If the prototype works, the researcher would code in a fast language that would not be easy to prototype (C++ or FORTRAN). Thus, we have two languages involved in the process of developing a new solution. One which is easy to prototype but is not suited for implementation (mostly due to being slow). And another which is not so easy to code, and consequently not easy to prototype, but suited for implementation because it is fast. Julia avoids such situations by being the <strong>same language that you prototype (ease of use) and implement the solution (speed)</strong>.</p>
<p>Also, Julia lets you use <strong>Unicode characters as variables or parameters</strong>. This means no more using <code>sigma</code> or <code>sigma_i</code>, and instead just use <span class="math inline">\(σ\)</span> or <span class="math inline">\(σᵢ\)</span> as you would in mathematical notation. When you see code for an algorithm or for a mathematical equation, you see almost the same notation and idioms. We call this feature <strong>“One-To-One Code and Math Relation”</strong> which is a powerful feature.</p>
<p>We think that the “Two-Language problem” and the “One-To-One Code and Math Relation” are best described by one of the creators of Julia, Alan Edelman, in a <a href="https://youtu.be/qGW0GT1rCvs">TEDx Talk</a> <span class="citation" data-cites="tedxtalksProgrammingLanguageHeal2020">(<a href="JuliaDataScience/references#ref-tedxtalksProgrammingLanguageHeal2020" role="doc-biblioref">TEDx Talks, 2020</a>)</span>.</p>
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">
<iframe src="https://www.youtube.com/embed/qGW0GT1rCvs" frameborder="0" allowfullscreen>
</iframe>
</div>
<h3 data-number="2.3.3" id="sec:multiple_dispatch"><span class="header-section-number">2.3.3</span> Multiple Dispatch</h3>
<p>Multiple dispatch is a powerful feature that allows us to extend existing functions or to define custom and complex behavior for new types. Suppose that you want to define two new <code>struct</code>s to denote two different animals:</p>
<pre class="language-julia"><code>abstract type Animal end
struct Fox &lt;: Animal
    weight::Float64
end
struct Chicken &lt;: Animal
    weight::Float64
end</code></pre>
<p>Basically, this says “define a fox which is an animal” and “define a chicken which is an animal.” Next, we might have one fox called Fiona and a chicken called Big Bird.</p>
<pre class="language-julia"><code>fiona = Fox(4.2)
big_bird = Chicken(2.9)</code></pre>
<p>Next, we want to know how much they weight together, for which we can write a function:</p>
<pre class="language-julia"><code>combined_weight(A1::Animal, A2::Animal) = A1.weight + A2.weight</code></pre>
<pre class="output"><code>combined_weight (generic function with 1 method)</code></pre>
<p>And we want to know whether they go well together. One way to implement that is to use conditionals:</p>
<pre class="language-julia"><code>function naive_trouble(A::Animal, B::Animal)
    if A isa Fox &amp;&amp; B isa Chicken
        return true
    elseif A isa Chicken &amp;&amp; B isa Fox
        return true
    elseif A isa Chicken &amp;&amp; B isa Chicken
        return false
    end
end</code></pre>
<pre class="output"><code>naive_trouble (generic function with 1 method)</code></pre>
<p>Now, let’s see whether leaving Fiona and Big Bird together would give trouble:</p>
<pre class="language-julia"><code>naive_trouble(fiona, big_bird)</code></pre>
<pre class="output"><code>true</code></pre>
<p>Okay, so this sounds right. Writing the <code>naive_trouble</code> function seems to be easy enough. However, using multiple dispatch to create a new function <code>trouble</code> can have their benefits. Let’s create our new function as follows:</p>
<pre class="language-julia"><code>trouble(F::Fox, C::Chicken) = true
trouble(C::Chicken, F::Fox) = true
trouble(C1::Chicken, C2::Chicken) = false</code></pre>
<pre class="output"><code>trouble (generic function with 3 methods)</code></pre>
<p>After defining these methods, <code>trouble</code> gives the same result as <code>naive_trouble</code>. For example:</p>
<pre class="language-julia"><code>trouble(fiona, big_bird)</code></pre>
<pre class="output"><code>true</code></pre>
<p>And leaving Big Bird alone with another chicken called Dora is also fine</p>
<pre class="language-julia"><code>dora = Chicken(2.2)
trouble(dora, big_bird)</code></pre>
<pre class="output"><code>false</code></pre>
<p>So, in this case, the benefit of multiple dispatch is that you can just declare types and Julia will find the correct method for your types. Even more so, for many cases when multiple dispatch is used inside code, the Julia compiler will actually optimize the function calls away. For example, we could write:</p>
<pre><code>function trouble(A::Fox, B::Chicken, C::Chicken)
    return trouble(A, B) || trouble(B, C) || trouble(C, A)
end</code></pre>
<p>Depending on the context, Julia can optimize this to:</p>
<pre><code>function trouble(A::Fox, B::Chicken, C::Chicken)
    return true || false || true
end</code></pre>
<p>because the compiler <strong>knows</strong> that <code>A</code> is a Fox, <code>B</code> is a chicken and so this can be replaced by the contents of the method <code>trouble(F::Fox, C::Chicken)</code>. The same holds for <code>trouble(C1::Chicken, C2::Chicken)</code>. Next, the compiler can optimize this to:</p>
<pre><code>function trouble(A::Fox, B::Chicken, C::Chicken)
    return true
end</code></pre>
<p>Another benefit of multiple dispatch is that when someone else now comes by and wants to compare the existing animals to their animal, a Zebra, then that’s possible. In their package, they can define a Zebra:</p>
<pre class="language-julia"><code>struct Zebra &lt;: Animal
    weight::Float64
end</code></pre>
<p>and also how the interactions with the existing animals would go:</p>
<pre class="language-julia"><code>trouble(F::Fox, Z::Zebra) = false
trouble(Z::Zebra, F::Fox) = false
trouble(C::Chicken, Z::Zebra) = false
trouble(Z::Zebra, F::Fox) = false</code></pre>
<pre class="output"><code>trouble (generic function with 6 methods)</code></pre>
<p>Now, we can see whether Marty (our zebra) is safe with Big Bird:</p>
<pre class="language-julia"><code>marty = Zebra(412)
trouble(big_bird, marty)</code></pre>
<pre class="output"><code>false</code></pre>
<p>Even better, we can also calculate <strong>the combined weight of zebra’s and other animals without defining any extra function at our side</strong>:</p>
<pre class="language-julia"><code>combined_weight(big_bird, marty)</code></pre>
<pre class="output"><code>414.9</code></pre>
<p>So, in summary, the code that was written with only Fox and Chicken in mind works even for types that it <strong>has never seen before</strong>! In practise, this means that Julia makes it often easy to re-use code from other projects.</p>
<p>If you are excited as much as we are by multiple dispatch, here are two more in-depth examples. The first is a <a href="https://storopoli.io/Bayesian-Julia/pages/1_why_Julia/#example_one-hot_vector">fast and elegant implementation of a one-hot vector</a> by <span class="citation" data-cites="storopoli2021bayesianjulia"><a href="JuliaDataScience/references#ref-storopoli2021bayesianjulia" role="doc-biblioref">Storopoli</a> (<a href="JuliaDataScience/references#ref-storopoli2021bayesianjulia" role="doc-biblioref">2021</a>)</span>. The second is an interview with <a href="https://www.chrisrackauckas.com/">Christopher Rackauckas</a> at <a href="https://youtu.be/moyPIhvw4Nk?t=2107">Tanmay Bakshi YouTube’s Channel</a> (see from time 35:07 onwards) <span class="citation" data-cites="tanmaybakshiBakingKnowledgeMachine2021">(<a href="JuliaDataScience/references#ref-tanmaybakshiBakingKnowledgeMachine2021" role="doc-biblioref">tanmay bakshi, 2021</a>)</span>. Chris mentions that, while using <a href="https://diffeq.sciml.ai/dev/"><code>DifferentialEquations.jl</code></a>, a package that he developed and currently maintains, a user filed an issue that his GPU-based quaternion ODE solver didn’t work. Chris was quite surprised by this request since he would never have expected that someone would combine GPU computations with quaternions and solving ODEs. He was even more surprised to discover that the user made a small mistake and that it all worked. Most of the merit is due to multiple dispatch and high user code/type sharing.</p>
<p>To conclude, we think that multiple dispatch is best explained by one of the creators of Julia: <a href="https://youtu.be/kc9HwsxE1OY">Stefan Karpinski at JuliaCon 2019</a>.</p>
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">
<iframe src="https://www.youtube.com/embed/kc9HwsxE1OY" frameborder="0" allowfullscreen>
</iframe>
</div>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="JuliaDataScience/programmers"><b>2.2</b> For Programmers</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="JuliaDataScience/julia_wild"><b>2.4</b> Julia in the Wild</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn8" role="doc-endnote"><p> 8. sometimes even faster than C.<a href="JuliaDataScience#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p> 9. a petaflop is one thousand trillion, or one quadrillion, operations per second.<a href="JuliaDataScience#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p> 10. LLVM stands for <strong>L</strong>ow <strong>L</strong>evel <strong>V</strong>irtual <strong>M</strong>achine, you can find more at the LLVM website (<a href="http://llvm.org" class="uri">http://llvm.org</a>).<a href="JuliaDataScience#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p> 11. if you like to learn more about how Julia is designed you should definitely check <span class="citation" data-cites="bezanson2017julia"><a href="JuliaDataScience/references#ref-bezanson2017julia" role="doc-biblioref">Bezanson et al.</a> (<a href="JuliaDataScience/references#ref-bezanson2017julia" role="doc-biblioref">2017</a>)</span>.<a href="JuliaDataScience#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p> 12. please note that the Julia results depicted above do not include compile time.<a href="JuliaDataScience#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>