<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>Julia Standard Library - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="JuliaDataScience/style.css"/>
    <script src="/mousetrap.min.js"></script>
    <!-- TODO: Add url_prefix. -->
  <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <script src="https://cdn.usefathom.com/script.js" data-site="EEJXHKTE" defer></script>
<script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="eB2Isj56H4g6ndupKwaKyHau7lCkTsVV"></script>
<link rel="stylesheet" href="JuliaDataScience/github.min.css">
<script src="JuliaDataScience/highlight.min.js"></script>
<script src="JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="JuliaDataScience/preface"><b>1</b> Preface</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/why_data_science"><b>1.1</b> What is Data Science?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/engineering"><b>1.2</b> Software Engineering</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/acknowledgements"><b>1.3</b> Acknowledgements</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/why_julia"><b>2</b> Why Julia?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/non-programmers"><b>2.1</b> For Non-Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/programmers"><b>2.2</b> For Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_accomplish"><b>2.3</b> What Julia Aims to Accomplish?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_wild"><b>2.4</b> Julia in the Wild</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/julia_basics"><b>3</b> Julia Basics</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/ide"><b>3.1</b> Development Environments</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/syntax"><b>3.2</b> Language Syntax</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/data_structures"><b>3.3</b> Native Data Structures</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filesystem"><b>3.4</b> Filesystem</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/standardlibrary"><b>3.5</b> Julia Standard Library</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/load_save"><b>4.1</b> Load and Save Files</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/index-and-summarize"><b>4.2</b> Index and Summarize</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filter_subset"><b>4.3</b> Filter and Subset</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/missing_data"><b>4.5</b> Types and Missing Data</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/variable-transformations"><b>4.7</b> Variable Transformations</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/groupby_combine"><b>4.8</b> Groupby and Combine</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/df_performance"><b>4.9</b> Performance</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/DataVisualizationMakie"><b>5</b> Data Visualization with Makie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/datavisMakie_attributes"><b>5.2</b> Attributes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/themes"><b>5.3</b> Themes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/using-latexstrings.jl"><b>5.4</b> Using LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_colors"><b>5.5</b> Colors and Colormaps</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/appendix"><b>6</b> Appendix</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/appendix_pkg"><b>6.1</b> Packages Versions</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/notation"><b>6.2</b> Notation</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/references"><b></b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="3.5" id="sec:standardlibrary"><span class="header-section-number">3.5</span> Julia Standard Library</h2>
<p>Julia has a <strong>rich standard library</strong> that is available with <em>every</em> Julia installation. Contrary to everything that we have seen so far, e.g. types, data structures and filesystem; you <strong>must load standard library modules into your environment</strong> to use a particular module or function.</p>
<p>This is done via <code>using</code> or <code>import</code>. In this book, we will load code via <code>using</code>:</p>
<pre class="julia"><code>using ModuleName</code></pre>
<p>After doing this, you can access all functions and types inside <code>ModuleName</code>.</p>
<h3 data-number="3.5.1" id="sec:dates"><span class="header-section-number">3.5.1</span> Dates</h3>
<p>Knowing how to handle dates and timestamps is important in data science. As we said in <em>Why Julia?</em> (Section <a href="JuliaDataScience/why_julia#sec:why_julia">2</a>) section, Python’s <code>pandas</code> uses its own <code>datetime</code> type to handle dates. The same is true in the R tidyverse’s <code>lubridate</code> package, which also defines its own <code>datetime</code> type to handle dates. In Julia packages don’t need to write their own dates logic, because Julia has a dates module in its standard library called <code>Dates</code>.</p>
<p>To begin, let’s load the <code>Dates</code> module:</p>
<pre class="julia"><code>using Dates</code></pre>
<h4 data-number="3.5.1.1" id="sec:dates_types"><span class="header-section-number">3.5.1.1</span> <code>Date</code> and <code>DateTime</code> Types</h4>
<p>The <code>Dates</code> standard library module has <strong>two types for working with dates</strong>:</p>
<ol type="1">
<li><code>Date</code>: representing time in days and</li>
<li><code>DateTime</code>: representing time in millisecond precision.</li>
</ol>
<p>We can construct <code>Date</code> and <code>DateTime</code> with the default constructor either by specifying an integer to represent year, month, day, hours and so on:</p>
<pre class="language-julia"><code>Date(1987) # year</code></pre>
<pre class="output"><code>1987-01-01</code></pre>
<pre class="language-julia"><code>Date(1987, 9) # year, month</code></pre>
<pre class="output"><code>1987-09-01</code></pre>
<pre class="language-julia"><code>Date(1987, 9, 13) # year, month, day</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<pre class="language-julia"><code>DateTime(1987, 9, 13, 21) # year, month, day, hour</code></pre>
<pre class="output"><code>1987-09-13T21:00:00</code></pre>
<pre class="language-julia"><code>DateTime(1987, 9, 13, 21, 21) # year, month, day, hour, minute</code></pre>
<pre class="output"><code>1987-09-13T21:21:00</code></pre>
<p>For the curious, September 13th 1987, 21:21 is the official time of birth of the first author, Jose.</p>
<p>We can also pass <code>Period</code> types to the default constructor. <strong><code>Period</code> types are the human-equivalent representation of time</strong> for the computer. Julia’s <code>Dates</code> have the following <code>Period</code> abstract subtypes:</p>
<pre class="language-julia"><code>subtypes(Period)</code></pre>
<pre class="output"><code>DatePeriod</code></pre>
<pre class="output"><code>TimePeriod</code></pre>
<p>which divide into the following concrete types, and they are pretty much self-explanatory:</p>
<pre class="language-julia"><code>subtypes(DatePeriod)</code></pre>
<pre class="output"><code>Day</code></pre>
<pre class="output"><code>Month</code></pre>
<pre class="output"><code>Quarter</code></pre>
<pre class="output"><code>Week</code></pre>
<pre class="output"><code>Year</code></pre>
<pre class="language-julia"><code>subtypes(TimePeriod)</code></pre>
<pre class="output"><code>Hour</code></pre>
<pre class="output"><code>Microsecond</code></pre>
<pre class="output"><code>Millisecond</code></pre>
<pre class="output"><code>Minute</code></pre>
<pre class="output"><code>Nanosecond</code></pre>
<pre class="output"><code>Second</code></pre>
<p>So, we could alternatively construct Jose’s official time of birth as:</p>
<pre class="language-julia"><code>DateTime(Year(1987), Month(9), Day(13), Hour(21), Minute(21))</code></pre>
<pre class="output"><code>1987-09-13T21:21:00</code></pre>
<h4 data-number="3.5.1.2" id="sec:dates_parsing"><span class="header-section-number">3.5.1.2</span> Parsing Dates</h4>
<p>Most of the time, we won’t be constructing <code>Date</code> or <code>DateTime</code> instances from scratch. Actually, we will probably be <strong>parsing strings as <code>Date</code> or <code>DateTime</code> types</strong>.</p>
<p>The <code>Date</code> and <code>DateTime</code> constructors can be fed a string and a format string. For example, the string <code>"19870913"</code> representing September 13th 1987 can be parsed with:</p>
<pre class="language-julia"><code>Date(&quot;19870913&quot;, &quot;yyyymmdd&quot;)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<p>Notice that the second argument is a string representation of the format. We have the first four digits representing year <code>y</code>, followed by two digits for month <code>m</code> and finally two digits for day <code>d</code>.</p>
<p>It also works for timestamps with <code>DateTime</code>:</p>
<pre class="language-julia"><code>DateTime(&quot;1987-09-13T21:21:00&quot;, &quot;yyyy-mm-ddTHH:MM:SS&quot;)</code></pre>
<pre class="output"><code>1987-09-13T21:21:00</code></pre>
<p>You can find more on how to specify different date formats in the <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat">Julia <code>Dates</code>’ documentation</a>. Don’t worry if you have to revisit it all the time, we ourselves do that too when working with dates and timestamps.</p>
<p>According to <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Constructors">Julia <code>Dates</code>’ documentation</a>, using the <code>Date(date_string, format_string)</code> method is fine if it’s only called a few times. If there are many similarly formatted date strings to parse, however, it is much more efficient to first create a <code>DateFormat</code> type, and then pass it instead of a raw format string. Then, our previous example becomes:</p>
<pre class="language-julia"><code>format = DateFormat(&quot;yyyymmdd&quot;)
Date(&quot;19870913&quot;, format)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<p>Alternatively, without loss of performance, you can use the string literal prefix <code>dateformat"..."</code>:</p>
<pre class="language-julia"><code>Date(&quot;19870913&quot;, dateformat&quot;yyyymmdd&quot;)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<h4 data-number="3.5.1.3" id="sec:dates_information"><span class="header-section-number">3.5.1.3</span> Extracting Date Information</h4>
<p>It is easy to <strong>extract desired information from <code>Date</code> and <code>DateTime</code> objects</strong>. First, let’s create an instance of a very special date:</p>
<pre class="language-julia"><code>my_birthday = Date(&quot;1987-09-13&quot;)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<p>We can extract anything we want from <code>my_birthday</code>:</p>
<pre class="language-julia"><code>year(my_birthday)</code></pre>
<pre class="output"><code>1987</code></pre>
<pre class="language-julia"><code>month(my_birthday)</code></pre>
<pre class="output"><code>9</code></pre>
<pre class="language-julia"><code>day(my_birthday)</code></pre>
<pre class="output"><code>13</code></pre>
<p>Julia’s <code>Dates</code> module also has <strong>compound functions that return a tuple of values</strong>:</p>
<pre class="language-julia"><code>yearmonth(my_birthday)</code></pre>
<pre class="output"><code>(1987, 9)</code></pre>
<pre class="language-julia"><code>monthday(my_birthday)</code></pre>
<pre class="output"><code>(9, 13)</code></pre>
<pre class="language-julia"><code>yearmonthday(my_birthday)</code></pre>
<pre class="output"><code>(1987, 9, 13)</code></pre>
<p>We can also see the day of the week and other handy stuff:</p>
<pre class="language-julia"><code>dayofweek(my_birthday)</code></pre>
<pre class="output"><code>7</code></pre>
<pre class="language-julia"><code>dayname(my_birthday)</code></pre>
<pre class="output"><code>Sunday</code></pre>
<pre class="language-julia"><code>dayofweekofmonth(my_birthday)</code></pre>
<pre class="output"><code>2</code></pre>
<p>Yep, Jose was born on the second Sunday of September.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> Here’s a handy tip to just recover weekdays from <code>Dates</code> instances. Just use a <code>filter</code> on <code>dayofweek(your_date) &lt;= 5</code>. For business day you can checkout the <a href="https://github.com/JuliaFinance/BusinessDays.jl"><code>BusinessDays.jl</code></a> package.</p>
</blockquote>
<h4 data-number="3.5.1.4" id="sec:dates_operations"><span class="header-section-number">3.5.1.4</span> Date Operations</h4>
<p>We can perform <strong>operations</strong> in <code>Dates</code> instances. For example, we can add days to a <code>Date</code> or <code>DateTime</code> instance. Notice that Julia’s <code>Dates</code> will automatically perform the adjustments necessary for leap years, and for months with 30 or 31 days (this is known as <em>calendrical</em> arithmetic).</p>
<pre class="language-julia"><code>my_birthday + Day(90)</code></pre>
<pre class="output"><code>1987-12-12</code></pre>
<p>We can add as many as we like:</p>
<pre class="language-julia"><code>my_birthday + Day(90) + Month(2) + Year(1)</code></pre>
<pre class="output"><code>1989-02-11</code></pre>
<p>In case you’re ever wondering: “What can I do with dates again? What is available?” then you can use <code>methodswith</code> to check it out. We show only the first 20 results here:</p>
<pre class="language-julia"><code>first(methodswith(Date), 20)</code></pre>
<pre class="output"><code>[1] firstdayofmonth(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/adjusters.jl:84
[2] firstdayofquarter(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/adjusters.jl:157
[3] firstdayofweek(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/adjusters.jl:52
[4] firstdayofyear(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/adjusters.jl:119
[5] lastdayofmonth(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/adjusters.jl:100
[6] lastdayofquarter(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/adjusters.jl:180
[7] lastdayofweek(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/adjusters.jl:68
[8] lastdayofyear(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/adjusters.jl:135
[9] +(t::Time, dt::Date) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:20
[10] +(dt::Date, t::Time) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:19
[11] +(dt::Date, y::Year) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:27
[12] +(dt::Date, z::Month) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:54
[13] +(x::Date, y::Quarter) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:73
[14] +(x::Date, y::Week) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:77
[15] +(x::Date, y::Day) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:79
[16] -(dt::Date, y::Year) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:35
[17] -(dt::Date, z::Month) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:66
[18] -(x::Date, y::Quarter) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:74
[19] -(x::Date, y::Week) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:78
[20] -(x::Date, y::Day) in Dates at /opt/hostedtoolcache/julia/1.6.3/x64/share/julia/stdlib/v1.6/Dates/src/arithmetic.jl:80</code></pre>
<p>From this, we can conclude that we can also use the plus <code>+</code> and minus <code>-</code> operator. Let’s see how old Jose is, in days:</p>
<pre class="language-julia"><code>today() - my_birthday</code></pre>
<pre class="output"><code>12476 days</code></pre>
<p>The <strong>default duration</strong> of <code>Date</code> types is a <code>Day</code> instance. For the <code>DateTime</code>, the default duration is <code>Millisecond</code> instance:</p>
<pre class="language-julia"><code>DateTime(today()) - DateTime(my_birthday)</code></pre>
<pre class="output"><code>1077926400000 milliseconds</code></pre>
<h4 data-number="3.5.1.5" id="sec:dates_intervals"><span class="header-section-number">3.5.1.5</span> Date Intervals</h4>
<p>One nice thing about <code>Dates</code> module is that we can also easily construct <strong>date and time intervals</strong>. Julia is clever enough to not have to define the whole interval types and operations that we covered in Section <a href="JuliaDataScience/data_structures#sec:ranges">3.3.5</a>. It just extends the functions and operations defined for range to <code>Date</code>’s types. This is known as multiple dispatch and we already covered this in <em>Why Julia?</em> (Section <a href="JuliaDataScience/why_julia#sec:why_julia">2</a>).</p>
<p>For example, suppose that you want to create a <code>Day</code> interval. This is easy done with the colon <code>:</code> operator:</p>
<pre class="language-julia"><code>Date(&quot;2021-01-01&quot;):Day(1):Date(&quot;2021-01-07&quot;)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-01-02</code></pre>
<pre class="output"><code>2021-01-03</code></pre>
<pre class="output"><code>2021-01-04</code></pre>
<pre class="output"><code>2021-01-05</code></pre>
<pre class="output"><code>2021-01-06</code></pre>
<pre class="output"><code>2021-01-07</code></pre>
<p>There is nothing special in using <code>Day(1)</code> as the interval, we can <strong>use whatever <code>Period</code> type</strong> as interval. For example, using 3 days as the interval:</p>
<pre class="language-julia"><code>Date(&quot;2021-01-01&quot;):Day(3):Date(&quot;2021-01-07&quot;)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-01-04</code></pre>
<pre class="output"><code>2021-01-07</code></pre>
<p>Or even months:</p>
<pre class="language-julia"><code>Date(&quot;2021-01-01&quot;):Month(1):Date(&quot;2021-03-01&quot;)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-02-01</code></pre>
<pre class="output"><code>2021-03-01</code></pre>
<p>Note that the <strong>type of this interval is a <code>StepRange</code> with the <code>Date</code> and concrete <code>Period</code> type</strong> we used as interval inside the colon <code>:</code> operator:</p>
<pre class="language-julia"><code>date_interval = Date(&quot;2021-01-01&quot;):Month(1):Date(&quot;2021-03-01&quot;)
typeof(date_interval)</code></pre>
<pre class="output"><code>StepRange{Date, Month}</code></pre>
<p>We can convert this to a <strong>vector</strong> with the <code>collect</code> function:</p>
<pre class="language-julia"><code>collected_date_interval = collect(date_interval)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-02-01</code></pre>
<pre class="output"><code>2021-03-01</code></pre>
<p>And have all the <strong>array functionalities available</strong>, like, for example, indexing:</p>
<pre class="language-julia"><code>collected_date_interval[end]</code></pre>
<pre class="output"><code>2021-03-01</code></pre>
<p>We can also <strong>broadcast date operations</strong> to our vector of <code>Date</code>s:</p>
<pre class="language-julia"><code>collected_date_interval .+ Day(10)</code></pre>
<pre class="output"><code>2021-01-11</code></pre>
<pre class="output"><code>2021-02-11</code></pre>
<pre class="output"><code>2021-03-11</code></pre>
<p>Similarly, these examples work for <code>DateTime</code> types too.</p>
<h3 data-number="3.5.2" id="sec:random"><span class="header-section-number">3.5.2</span> Random Numbers</h3>
<p>Another important module in Julia’s standard library is the <code>Random</code> module. This module deals with <strong>random number generation</strong>. <code>Random</code> is a rich library and, if you’re interested, you should consult <a href="https://docs.julialang.org/en/v1/stdlib/Random/">Julia’s <code>Random</code> documentation</a>. We will cover <em>only</em> three functions: <code>rand</code>, <code>randn</code> and <code>seed!</code>.</p>
<p>To begin, we first load the <code>Random</code> module. Since we know exactly what we want to load, we can just as well explicitly load the methods that we want to use:</p>
<pre class="julia"><code>using Random: rand, randn, seed!</code></pre>
<p>We have <strong>two main functions that generate random numbers</strong>:</p>
<ul>
<li><code>rand</code>: samples a <strong>random element</strong> of a data structure or type.</li>
<li><code>randn</code>: generates a random number that follows a <strong>standard normal distribution</strong> (mean 0 and standard deviation 1) of a specific type.</li>
</ul>
<blockquote>
<p><strong><em>NOTE:</em></strong> Note that those two functions are already in the Julia <code>Base</code> module. So, you don’t need to import <code>Random</code> if you’re planning to use them.</p>
</blockquote>
<h4 data-number="3.5.2.1" id="sec:random_rand"><span class="header-section-number">3.5.2.1</span> <code>rand</code></h4>
<p>By default, if you call <code>rand</code> without arguments it will return a <code>Float64</code> in the interval <span class="math inline">\([0, 1)\)</span>, which means between 0 inclusive to 1 exclusive:</p>
<pre class="language-julia"><code>rand()</code></pre>
<pre class="output"><code>0.3396211745998581</code></pre>
<p>You can modify <code>rand</code> arguments in several ways. For example, suppose you want more than 1 random number:</p>
<pre class="language-julia"><code>rand(3)</code></pre>
<pre class="output"><code>[0.019735815513740373, 0.2822789589194197, 0.5514572737295276]</code></pre>
<p>Or, you want a different interval:</p>
<pre class="language-julia"><code>rand(1.0:10.0)</code></pre>
<pre class="output"><code>3.0</code></pre>
<p>You can also specify a different step size inside the interval and a different type. Here we are using numbers without the dot <code>.</code> so Julia will interpret them as <code>Int64</code>:</p>
<pre class="language-julia"><code>rand(2:2:20)</code></pre>
<pre class="output"><code>6</code></pre>
<p>You can also mix and match arguments:</p>
<pre class="language-julia"><code>rand(2:2:20, 3)</code></pre>
<pre class="output"><code>[20, 18, 14]</code></pre>
<p>It also supports a collection of elements as a tuple:</p>
<pre class="language-julia"><code>rand((42, &quot;Julia&quot;, 3.14))</code></pre>
<pre class="output"><code>Julia</code></pre>
<p>And also arrays:</p>
<pre class="language-julia"><code>rand([1, 2, 3])</code></pre>
<pre class="output"><code>3</code></pre>
<p><code>Dict</code>s:</p>
<pre class="language-julia"><code>rand(Dict(:one =&gt; 1, :two =&gt; 2))</code></pre>
<pre class="output"><code>:two =&gt; 2</code></pre>
<p>To finish off all the <code>rand</code> arguments options, you can specify the desired random number dimensions in a tuple. If you do this, the returned type will be an array. For example, here’s a 2x2 matrix of <code>Float64</code> numbers between 1.0 and 3.0:</p>
<pre class="language-julia"><code>rand(1.0:3.0, (2, 2))</code></pre>
<pre class="output"><code>2×2 Matrix{Float64}:
 1.0  2.0
 1.0  1.0</code></pre>
<h4 data-number="3.5.2.2" id="sec:random_randn"><span class="header-section-number">3.5.2.2</span> <code>randn</code></h4>
<p><code>randn</code> follows the same general principle from <code>rand</code> but now it only returns numbers generated from the <strong>standard normal distribution</strong>. The standard normal distribution is the normal distribution with mean 0 and standard deviation 1. The default type is <code>Float64</code> and it only allows for subtypes of <code>AbstractFloat</code> or <code>Complex</code>:</p>
<pre class="language-julia"><code>randn()</code></pre>
<pre class="output"><code>-0.28302376686614356</code></pre>
<p>We can only specify the size:</p>
<pre class="language-julia"><code>randn((2, 2))</code></pre>
<pre class="output"><code>2×2 Matrix{Float64}:
  0.944211  -0.894515
 -0.834748   1.77925</code></pre>
<h4 data-number="3.5.2.3" id="sec:random_seed"><span class="header-section-number">3.5.2.3</span> <code>seed!</code></h4>
<p>To finish off the <code>Random</code> overview, let’s talk about <strong>reproducibility</strong>. Often, we want to make something <strong>replicable</strong>. Meaning that, we want the random number generator to generate the <strong>same random sequence of numbers</strong>. We can do so with the <code>seed!</code> function:</p>
<pre class="language-julia"><code>seed!(123)
rand(3)</code></pre>
<pre class="output"><code>[0.7684476751965699, 0.940515000715187, 0.6739586945680673]</code></pre>
<pre class="language-julia"><code>seed!(123)
rand(3)</code></pre>
<pre class="output"><code>[0.7684476751965699, 0.940515000715187, 0.6739586945680673]</code></pre>
<p>In order to avoid tedious and inefficient repetition of <code>seed!</code> all over the place, we can instead define an instance of a <code>seed!</code> and pass it as a first argument of <strong>either <code>rand</code> or <code>randn</code></strong>.</p>
<pre class="language-julia"><code>my_seed = seed!(123)</code></pre>
<pre class="output"><code>MersenneTwister(123)</code></pre>
<pre class="language-julia"><code>rand(my_seed, 3)</code></pre>
<pre class="output"><code>[0.3954531123351086, 0.3132439558075186, 0.6625548164736534]</code></pre>
<pre class="language-julia"><code>rand(my_seed, 3)</code></pre>
<pre class="output"><code>[0.3954531123351086, 0.3132439558075186, 0.6625548164736534]</code></pre>
<blockquote>
<p><strong><em>NOTE:</em></strong> If you want your code to be reproducible you can just call <code>seed!</code> in the beginning of your script. This will take care of reproducibility in sequential <code>Random</code> operations. No need to use it all <code>rand</code> and <code>randn</code> usage.</p>
</blockquote>
<h3 data-number="3.5.3" id="sec:downloads"><span class="header-section-number">3.5.3</span> Downloads</h3>
<p>One last thing from Julia’s standard library for us to cover is the <strong><code>Download</code> module</strong>. It will be really brief because we will only be covering a single function named <code>download</code>.</p>
<p>Suppose you want to <strong>download a file from the internet to your local storage</strong>. You can accomplish this with the <code>download</code> function. The first and only required argument is the file’s url. You can also specify as a second argument the desired output path for the downloaded file (don’t forget the filesystem best practices!). If you don’t specify a second argument, Julia will, by default, create a temporary file with the <code>tempfile</code> function.</p>
<p>Let’s load the <code>download</code> method:</p>
<pre class="julia"><code>using Download: download</code></pre>
<p>For example, let’s download our <a href="https://github.com/JuliaDataScience/JuliaDataScience"><code>JuliaDataScience</code> GitHub repository</a> <code>Project.toml</code> file. Note that <code>download</code> function is not exported by <code>Downloads</code> module, so we have to use the <code>Module.function</code> syntax. By default, it returns a string that holds the file path for the downloaded file:</p>
<pre class="language-julia"><code>url = &quot;https://raw.githubusercontent.com/JuliaDataScience/JuliaDataScience/main/Project.toml&quot;

my_file = Downloads.download(url) # tempfile() being created</code></pre>
<pre class="output"><code>/tmp/jl_Qwzown</code></pre>
<p>With <code>readlines</code>, we can look at the first 4 lines of our downloaded file:</p>
<pre class="language-julia"><code>readlines(my_file)[1:4]</code></pre>
<pre class="output"><code>4-element Vector{String}:
 &quot;name = \&quot;JDS\&quot;&quot;
 &quot;uuid = \&quot;6c596d62-2771-44f8-8373-3ec4b616ee9d\&quot;&quot;
 &quot;authors = [\&quot;Jose Storopoli\&quot;, \&quot;Rik Huijzer\&quot;, \&quot;Lazaro Alonso\&quot;]&quot;
 &quot;version = \&quot;0.1.0\&quot;&quot;</code></pre>
<blockquote>
<p><strong><em>NOTE:</em></strong> For more complex HTTP interactions such as interacting with web APIs, see the <a href="https://github.com/JuliaWeb/HTTP.jl"><code>HTTP.jl</code> package</a> package.</p>
</blockquote>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="JuliaDataScience/filesystem"><b>3.4</b> Filesystem</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>