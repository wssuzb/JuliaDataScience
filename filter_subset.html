<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>Filter and Subset - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="JuliaDataScience/style.css"/>
    <script src="/mousetrap.min.js"></script>
    <!-- TODO: Add url_prefix. -->
  <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <script src="https://cdn.usefathom.com/script.js" data-site="EEJXHKTE" defer></script>
<script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="eB2Isj56H4g6ndupKwaKyHau7lCkTsVV"></script>
<link rel="stylesheet" href="JuliaDataScience/github.min.css">
<script src="JuliaDataScience/highlight.min.js"></script>
<script src="JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="JuliaDataScience/preface"><b>1</b> Preface</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/why_data_science"><b>1.1</b> What is Data Science?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/engineering"><b>1.2</b> Software Engineering</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/acknowledgements"><b>1.3</b> Acknowledgements</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/why_julia"><b>2</b> Why Julia?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/non-programmers"><b>2.1</b> For Non-Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/programmers"><b>2.2</b> For Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_accomplish"><b>2.3</b> What Julia Aims to Accomplish?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_wild"><b>2.4</b> Julia in the Wild</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/julia_basics"><b>3</b> Julia Basics</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/ide"><b>3.1</b> Development Environments</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/syntax"><b>3.2</b> Language Syntax</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/data_structures"><b>3.3</b> Native Data Structures</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filesystem"><b>3.4</b> Filesystem</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/standardlibrary"><b>3.5</b> Julia Standard Library</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/load_save"><b>4.1</b> Load and Save Files</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/index-and-summarize"><b>4.2</b> Index and Summarize</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filter_subset"><b>4.3</b> Filter and Subset</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/missing_data"><b>4.5</b> Types and Missing Data</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/variable-transformations"><b>4.7</b> Variable Transformations</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/groupby_combine"><b>4.8</b> Groupby and Combine</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/df_performance"><b>4.9</b> Performance</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/DataVisualizationMakie"><b>5</b> Data Visualization with Makie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/datavisMakie_attributes"><b>5.2</b> Attributes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/themes"><b>5.3</b> Themes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/using-latexstrings.jl"><b>5.4</b> Using LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_colors"><b>5.5</b> Colors and Colormaps</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/appendix"><b>6</b> Appendix</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/appendix_pkg"><b>6.1</b> Packages Versions</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/notation"><b>6.2</b> Notation</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/references"><b></b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="4.3" id="sec:filter_subset"><span class="header-section-number">4.3</span> Filter and Subset</h2>
<p>There are two ways to remove rows from a <code>DataFrame</code>, one is <code>filter</code> (Section <a href="JuliaDataScience/filter_subset#sec:filter">4.3.1</a>) and the other is <code>subset</code> (Section <a href="JuliaDataScience/filter_subset#sec:subset">4.3.2</a>). <code>filter</code> was added earlier to <code>DataFrames.jl</code>, is more powerful and more consistent with syntax from Julia base, so that is why we start discussing <code>filter</code> first. <code>subset</code> is newer and often more convenient.</p>
<h3 data-number="4.3.1" id="sec:filter"><span class="header-section-number">4.3.1</span> Filter</h3>
<p>From this point on, we start to get into the more powerful features of <code>DataFrames.jl</code>. To do this, we need to learn some functions, such as <code>select</code> and <code>filter</code>. But don’t worry! It might be a relief to know that the <strong>general design goal of <code>DataFrames.jl</code> is to keep the number of functions that a user has to learn to a minimum<a href="JuliaDataScience#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a></strong>.</p>
<p>Like before, we resume from the <code>grades_2020</code>:</p>
<pre class="language-julia"><code>grades_2020()</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Sally</td>
<td style="text-align: right;">1.0</td>
</tr>
<tr class="even">
<td style="text-align: right;">Bob</td>
<td style="text-align: right;">5.0</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
<tr class="even">
<td style="text-align: right;">Hank</td>
<td style="text-align: right;">4.0</td>
</tr>
</tbody>
</table>
<p>We can filter rows by using <code>filter(source =&gt; f::Function, df)</code>. Note how this function is very similar to the function <code>filter(f::Function, V::Vector)</code> from Julia <code>Base</code> module. This is because <code>DataFrames.jl</code> uses <strong>multiple dispatch</strong> (see Section <a href="JuliaDataScience/julia_accomplish#sec:multiple_dispatch">2.3.3</a>) to define a new method of <code>filter</code> that accepts a <code>DataFrame</code> as argument.</p>
<p>At first sight, defining and working with a function <code>f</code> for filtering can be a bit difficult to use in practice. Hold tight, that effort is well-paid, since <strong>it is a very powerful way of filtering data</strong>. As a simple example, we can create a function <code>equals_alice</code> that checks whether its input equals “Alice”:</p>
<pre class="language-julia"><code>equals_alice(name::String) = name == &quot;Alice&quot;
equals_alice(&quot;Bob&quot;)</code></pre>
<pre class="output"><code>false</code></pre>
<pre class="language-julia"><code>equals_alice(&quot;Alice&quot;)</code></pre>
<pre class="output"><code>true</code></pre>
<p>Equipped with such a function, we can use it as our function <code>f</code> to filter out all the rows for which <code>name</code> equals “Alice”:</p>
<pre class="language-julia"><code>filter(:name =&gt; equals_alice, grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Note that this doesn’t only work for <code>DataFrame</code>s, but also for vectors:</p>
<pre class="language-julia"><code>filter(equals_alice, [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Dave&quot;])</code></pre>
<pre class="output"><code>[&quot;Alice&quot;]</code></pre>
<p>We can make it a bit less verbose by using an <strong>anonymous function</strong> (see Section <a href="JuliaDataScience/syntax#sec:function_anonymous">3.2.4.4</a>):</p>
<pre class="language-julia"><code>filter(n -&gt; n == &quot;Alice&quot;, [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Dave&quot;])</code></pre>
<pre class="output"><code>[&quot;Alice&quot;]</code></pre>
<p>which we can also use on <code>grades_2020</code>:</p>
<pre class="language-julia"><code>filter(:name =&gt; n -&gt; n == &quot;Alice&quot;, grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>To recap, this function call can be read as “for each element in the column <code>:name</code>, let’s call the element <code>n</code>, check whether <code>n</code> equals Alice.” For some people, this is still too verbose. Luckily, Julia has added a <em>partial function application</em> of <code>==</code>. The details are not important – just know that you can use it just like any other function:</p>
<pre class="language-julia"><code>filter(:name =&gt; ==(&quot;Alice&quot;), grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>To get all the rows which are <em>not</em> Alice, <code>==</code> (equality) can be replaced by <code>!=</code> (inequality) in all previous examples:</p>
<pre class="language-julia"><code>filter(:name =&gt; !=(&quot;Alice&quot;), grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Sally</td>
<td style="text-align: right;">1.0</td>
</tr>
<tr class="even">
<td style="text-align: right;">Bob</td>
<td style="text-align: right;">5.0</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Hank</td>
<td style="text-align: right;">4.0</td>
</tr>
</tbody>
</table>
<p>Now, to show <strong>why anonymous functions are so powerful</strong>, we can come up with a slightly more complex filter. In this filter, we want to have the people whose names start with A or B <strong>and</strong> have a grade above 6:</p>
<pre class="language-julia"><code>function complex_filter(name, grade)::Bool
    interesting_name = startswith(name, &#39;A&#39;) || startswith(name, &#39;B&#39;)
    interesting_grade = 6 &lt; grade
    interesting_name &amp;&amp; interesting_grade
end</code></pre>
<pre class="language-julia"><code>filter([:name, :grade_2020] =&gt; complex_filter, grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<h3 data-number="4.3.2" id="sec:subset"><span class="header-section-number">4.3.2</span> Subset</h3>
<p>The <code>subset</code> function was added to make it easier to work with missing values (Section <a href="JuliaDataScience/missing_data#sec:missing_data">4.5</a>). In contrast to <code>filter</code>, <code>subset</code> works on complete columns instead of rows or single values. If we want to use our earlier defined functions, we should wrap it inside <code>ByRow</code>:</p>
<pre class="language-julia"><code>subset(grades_2020(), :name =&gt; ByRow(equals_alice))</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Also note that the <code>DataFrame</code> is now the first argument <code>subset(df, args...)</code>, whereas in <code>filter</code> it was the second one <code>filter(f, df)</code>. The reason for this is that Julia defines filter as <code>filter(f, V::Vector)</code> and <code>DataFrames.jl</code> chose to maintain consistency with existing Julia functions that were extended to <code>DataFrame</code>s types by multiple dispatch.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> Most of native <code>DataFrames.jl</code> functions, which <code>subset</code> belongs to, have a <strong>consistent function signature that always takes a <code>DataFrame</code> as first argument</strong>.</p>
</blockquote>
<p>Just like with <code>filter</code>, we can also use anonymous functions inside <code>subset</code>:</p>
<pre class="language-julia"><code>subset(grades_2020(), :name =&gt; ByRow(name -&gt; name == &quot;Alice&quot;))</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Or, the partial function application for <code>==</code>:</p>
<pre class="language-julia"><code>subset(grades_2020(), :name =&gt; ByRow(==(&quot;Alice&quot;)))</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Ultimately, let’s show the real power of <code>subset</code>. First, we create a dataset with some missing values:</p>
<pre class="language-julia"><code>function salaries()
    names = [&quot;John&quot;, &quot;Hank&quot;, &quot;Karen&quot;, &quot;Zed&quot;]
    salary = [1_900, 2_800, 2_800, missing]
    DataFrame(; names, salary)
end
salaries()</code></pre>
<div id="tbl:salaries">
<table>
<caption>Table 6: Salaries.</caption>
<thead>
<tr class="header">
<th style="text-align: right;">names</th>
<th style="text-align: right;">salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">John</td>
<td style="text-align: right;">1900</td>
</tr>
<tr class="even">
<td style="text-align: right;">Hank</td>
<td style="text-align: right;">2800</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Karen</td>
<td style="text-align: right;">2800</td>
</tr>
<tr class="even">
<td style="text-align: right;">Zed</td>
<td style="text-align: right;">missing</td>
</tr>
</tbody>
</table>
</div>
<p>This data is about a plausible situation where you want to figure out your colleagues’ salaries, and haven’t figured it out for Zed yet. Even though we don’t want to encourage these practices, we suspect it is an interesting example. Suppose we want to know who earns more than 2000. If we use <code>filter</code>, without taking the <code>missing</code> values into account, it will fail:</p>
<pre class="language-julia"><code>filter(:salary =&gt; &gt;(2_000), salaries())</code></pre>
<pre class="output"><code>TypeError: non-boolean (Missing) used in boolean context
Stacktrace:
  [1] (::DataFrames.var&quot;#89#90&quot;{Base.Fix2{typeof(&gt;), Int64}})(x::Missing)
    @ DataFrames ~/.julia/packages/DataFrames/vuMM8/src/abstractdataframe/abstractdataframe.jl:1043
  ...</code></pre>
<p><code>subset</code> will also fail, but it will fortunately point us towards an easy solution:</p>
<pre class="language-julia"><code>subset(salaries(), :salary =&gt; ByRow(&gt;(2_000)))</code></pre>
<pre class="output"><code>ArgumentError: missing was returned in condition number 1 but only true or false are allowed; pass skipmissing=true to skip missing values
Stacktrace:
  [1] _and(x::Missing)
    @ DataFrames ~/.julia/packages/DataFrames/vuMM8/src/abstractdataframe/subset.jl:11
  ...</code></pre>
<p>So, we just need to pass the keyword argument <code>skipmissing=true</code>:</p>
<pre class="language-julia"><code>subset(salaries(), :salary =&gt; ByRow(&gt;(2_000)); skipmissing=true)</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">names</th>
<th style="text-align: right;">salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Hank</td>
<td style="text-align: right;">2800</td>
</tr>
<tr class="even">
<td style="text-align: right;">Karen</td>
<td style="text-align: right;">2800</td>
</tr>
</tbody>
</table>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="JuliaDataScience/index-and-summarize"><b>4.2</b> Index and Summarize</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="JuliaDataScience/select"><b>4.4</b> Select</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn15" role="doc-endnote"><p> 15. According to Bogumił Kamiński (lead developer and maintainer of <code>DataFrames.jl</code>) on Discourse (<a href="https://discourse.julialang.org/t/pull-dataframes-columns-to-the-front/60327/5" class="uri">https://discourse.julialang.org/t/pull-dataframes-columns-to-the-front/60327/5</a>).<a href="JuliaDataScience#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>