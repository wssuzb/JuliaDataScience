<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>GLMakie.jl - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="JuliaDataScience/style.css"/>
    <script src="/mousetrap.min.js"></script>
    <!-- TODO: Add url_prefix. -->
  <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <script src="https://cdn.usefathom.com/script.js" data-site="EEJXHKTE" defer></script>
<script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="eB2Isj56H4g6ndupKwaKyHau7lCkTsVV"></script>
<link rel="stylesheet" href="JuliaDataScience/github.min.css">
<script src="JuliaDataScience/highlight.min.js"></script>
<script src="JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="JuliaDataScience/preface"><b>1</b> Preface</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/why_data_science"><b>1.1</b> What is Data Science?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/engineering"><b>1.2</b> Software Engineering</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/acknowledgements"><b>1.3</b> Acknowledgements</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/why_julia"><b>2</b> Why Julia?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/non-programmers"><b>2.1</b> For Non-Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/programmers"><b>2.2</b> For Programmers</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_accomplish"><b>2.3</b> What Julia Aims to Accomplish?</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/julia_wild"><b>2.4</b> Julia in the Wild</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/julia_basics"><b>3</b> Julia Basics</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/ide"><b>3.1</b> Development Environments</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/syntax"><b>3.2</b> Language Syntax</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/data_structures"><b>3.3</b> Native Data Structures</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filesystem"><b>3.4</b> Filesystem</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/standardlibrary"><b>3.5</b> Julia Standard Library</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/load_save"><b>4.1</b> Load and Save Files</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/index-and-summarize"><b>4.2</b> Index and Summarize</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/filter_subset"><b>4.3</b> Filter and Subset</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/missing_data"><b>4.5</b> Types and Missing Data</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/variable-transformations"><b>4.7</b> Variable Transformations</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/groupby_combine"><b>4.8</b> Groupby and Combine</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/df_performance"><b>4.9</b> Performance</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/DataVisualizationMakie"><b>5</b> Data Visualization with Makie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/datavisMakie_attributes"><b>5.2</b> Attributes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/themes"><b>5.3</b> Themes</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/using-latexstrings.jl"><b>5.4</b> Using LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_colors"><b>5.5</b> Colors and Colormaps</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/appendix"><b>6</b> Appendix</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/appendix_pkg"><b>6.1</b> Packages Versions</a></li>
<li><a class="menu-level-2" href="JuliaDataScience/notation"><b>6.2</b> Notation</a></li>
<li><a class="menu-level-1" href="JuliaDataScience/references"><b></b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="5.7" id="sec:glmakie"><span class="header-section-number">5.7</span> GLMakie.jl</h2>
<p><code>CairoMakie.jl</code> supplies all our needs for static 2D images. But sometimes we want interactivity, especially when we are dealing with 3D images. Visualizing data in 3D is also a common practice to gain insight from your data. This is where <code>GLMakie.jl</code> might be helpful, since it uses <a href="http://www.opengl.org/">OpenGL</a> as a backend that adds interactivity and responsiveness to plots. Like before, a simple plot includes, of course, lines and points. So, we will start with those and since we already know how layouts work, we will put that into practice.</p>
<h3 data-number="5.7.1" id="scatters-and-lines"><span class="header-section-number">5.7.1</span> Scatters and Lines</h3>
<p>For scatter plots we have two options, the first one is <code>scatter(x, y, z)</code> and the second one is <code>meshscatter(x, y, z)</code>. In the first one markers don’t scale in the axis directions, but in the later they do because they are actual geometries in 3D space. See the next example:</p>
<pre><code>using GLMakie
GLMakie.activate!()</code></pre>
<pre class="language-julia"><code>function scatters_in_3D()
    seed!(123)
    xyz = randn(10, 3)
    x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3]
    fig = Figure(resolution=(1600, 400))
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness=0.5)
    scatter!(ax1, x, y, z; markersize=50)
    meshscatter!(ax2, x, y, z; markersize=0.25)
    hm = meshscatter!(ax3, x, y, z; markersize=0.25,
        marker=FRect3D(Vec3f(0), Vec3f(1)), color=1:size(xyz)[2],
        colormap=:plasma, transparency=false)
    Colorbar(fig[1, 4], hm, label=&quot;values&quot;, height=Relative(0.5))
    fig
end
scatters_in_3D()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_scatters_in_3D_.png" id="fig:scatters_in_3D" alt="Figure 36: Scatters in 3D." /><figcaption aria-hidden="true">Figure 36: Scatters in 3D.</figcaption>
</figure>
<p>Note also, that a different geometry can be passed as markers, i.e., a square/rectangle and we can assign a <code>colormap</code> for them as well. In the middle panel one could get perfect spheres by doing <code>aspect = :data</code> as in the right panel.</p>
<p>And doing <code>lines</code> or <code>scatterlines</code> is also straightforward:</p>
<pre class="language-julia"><code>function lines_in_3D()
    seed!(123)
    xyz = randn(10, 3)
    x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3]
    fig = Figure(resolution=(1600, 400))
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness=0.5)
    lines!(ax1, x, y, z; color=1:size(xyz)[2], linewidth=3)
    scatterlines!(ax2, x, y, z; markersize=50)
    hm = meshscatter!(ax3, x, y, z; markersize=0.2, color=1:size(xyz)[2])
    lines!(ax3, x, y, z; color=1:size(xyz)[2])
    Colorbar(fig[2, 1], hm; label=&quot;values&quot;, height=15, vertical=false,
        flipaxis=false, ticksize=15, tickalign=1, width=Relative(3.55 / 4))
    fig
end
lines_in_3D()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_lines_in_3D_.png" id="fig:lines_in_3D" alt="Figure 37: Lines in 3D." /><figcaption aria-hidden="true">Figure 37: Lines in 3D.</figcaption>
</figure>
<p>Plotting a <code>surface</code> is also easy to do as well as a <code>wireframe</code> and <code>contour</code> lines in 3D.</p>
<h3 data-number="5.7.2" id="surfaces-wireframe-contour-contourf-and-contour3d"><span class="header-section-number">5.7.2</span> Surfaces, wireframe, contour, contourf and contour3d</h3>
<p>To show these cases we’ll use the following <code>peaks</code> function:</p>
<pre class="language-julia"><code>function peaks(; n=49)
    x = LinRange(-3, 3, n)
    y = LinRange(-3, 3, n)
    a = 3 * (1 .- x&#39;) .^ 2 .* exp.(-(x&#39; .^ 2) .- (y .+ 1) .^ 2)
    b = 10 * (x&#39; / 5 .- x&#39; .^ 3 .- y .^ 5) .* exp.(-x&#39; .^ 2 .- y .^ 2)
    c = 1 / 3 * exp.(-(x&#39; .+ 1) .^ 2 .- y .^ 2)
    return (x, y, a .- b .- c)
end</code></pre>
<p>The output for the different plotting functions is</p>
<pre class="language-julia"><code>function plot_peaks_function()
    x, y, z = peaks()
    x2, y2, z2 = peaks(; n=15)
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1)) for i = 1:3]
    hm = surface!(axs[1], x, y, z)
    wireframe!(axs[2], x2, y2, z2)
    contour3d!(axs[3], x, y, z; levels=20)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
plot_peaks_function()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_plot_peaks_function_.png" id="fig:plot_peaks_function" alt="Figure 38: Plot peaks function." /><figcaption aria-hidden="true">Figure 38: Plot peaks function.</figcaption>
</figure>
<p>But, it can also be plotted with a <code>heatmap(x, y, z)</code>, <code>contour(x, y, z)</code> or <code>contourf(x, y, z)</code>:</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf()
    x, y, z = peaks()
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis(fig[1, i]; aspect=DataAspect()) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
heatmap_contour_and_contourf()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_heatmap_contour_and_contourf_.png" id="fig:heatmap_contour_and_contourf" alt="Figure 39: Heatmap contour and contourf." /><figcaption aria-hidden="true">Figure 39: Heatmap contour and contourf.</figcaption>
</figure>
<p>Additionally, by changing <code>Axis</code> to an <code>Axis3</code>, these plots will be automatically be in the x-y plane:</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf_in_a_3d_plane()
    x, y, z = peaks()
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis3(fig[1, i]) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
heatmap_contour_and_contourf_in_a_3d_plane()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_heatmap_contour_and_contourf_in_a_3d_plane_.png" id="fig:heatmap_contour_and_contourf_in_a_3d_plane" alt="Figure 40: Heatmap contour and contourf in a 3d plane." /><figcaption aria-hidden="true">Figure 40: Heatmap contour and contourf in a 3d plane.</figcaption>
</figure>
<p>Something else that is easy to do is to mix all these plotting functions into just one plot, namely:</p>
<pre><code>using TestImages</code></pre>
<pre class="language-julia"><code>function mixing_surface_contour3d_contour_and_contourf()
    img = testimage(&quot;coffee.png&quot;)
    x, y, z = peaks()
    cmap = :Spectral_11
    fig = Figure(resolution=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), elevation=pi / 6, xzpanelcolor=(:black, 0.75),
        perspectiveness=0.5, yzpanelcolor=:black, zgridcolor=:grey70,
        ygridcolor=:grey70, xgridcolor=:grey70)
    ax2 = Axis3(fig[1, 3]; aspect=(1, 1, 1), elevation=pi / 6, perspectiveness=0.5)
    hm = surface!(ax1, x, y, z; colormap=(cmap, 0.95), shading=true)
    contour3d!(ax1, x, y, z .+ 0.02; colormap=cmap, levels=20, linewidth=2)
    xmin, ymin, zmin = minimum(ax1.finallimits[])
    xmax, ymax, zmax = maximum(ax1.finallimits[])
    contour!(ax1, x, y, z; colormap=cmap, levels=20, transformation=(:xy, zmax))
    contourf!(ax1, x, y, z; colormap=cmap, transformation=(:xy, zmin))
    Colorbar(fig[1, 2], hm, width=15, ticksize=15, tickalign=1, height=Relative(0.35))
    # transformations into planes
    heatmap!(ax2, x, y, z; colormap=:viridis, transformation=(:yz, 3.5))
    contourf!(ax2, x, y, z; colormap=:CMRmap, transformation=(:xy, -3.5))
    contourf!(ax2, x, y, z; colormap=:bone_1, transformation=(:xz, 3.5))
    image!(ax2, -3 .. 3, -3 .. 2, rotr90(img); transformation=(:xy, 3.8))
    xlims!(ax2, -3.8, 3.8)
    ylims!(ax2, -3.8, 3.8)
    zlims!(ax2, -3.8, 3.8)
    fig
end
mixing_surface_contour3d_contour_and_contourf()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_mixing_surface_contour3d_contour_and_contourf_.png" id="fig:mixing_surface_contour3d_contour_and_contourf" style="width:60.0%" alt="Figure 41: Mixing surface, contour3d, contour and contourf." /><figcaption aria-hidden="true">Figure 41: Mixing surface, contour3d, contour and contourf.</figcaption>
</figure>
<p>Not bad, right? From there is clear that any <code>heatmap</code>’s, <code>contour</code>’s, <code>contourf</code>’s or <code>image</code> can be plotted into any plane.</p>
<h3 data-number="5.7.3" id="arrows-and-streamplots"><span class="header-section-number">5.7.3</span> Arrows and Streamplots</h3>
<p><code>arrows</code> and <code>streamplot</code> are plots that might be useful when we want to know the directions that a given variable will follow. See a demonstration below<a href="JuliaDataScience#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>:</p>
<pre><code>using LinearAlgebra</code></pre>
<pre class="language-julia"><code>function arrows_and_streamplot_in_3d()
    ps = [Point3f(x, y, z) for x = -3:1:3 for y = -3:1:3 for z = -3:1:3]
    ns = map(p -&gt; 0.1 * rand() * Vec3f(p[2], p[3], p[1]), ps)
    lengths = norm.(ns)
    flowField(x, y, z) = Point(-y + x * (-1 + x^2 + y^2)^2, x + y * (-1 + x^2 + y^2)^2,
        z + x * (y - z^2))
    fig = Figure(resolution=(1200, 800), fontsize=26)
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1), perspectiveness=0.5) for i = 1:2]
    arrows!(axs[1], ps, ns, color=lengths, arrowsize=Vec3f0(0.2, 0.2, 0.3),
        linewidth=0.1)
    streamplot!(axs[2], flowField, -4 .. 4, -4 .. 4, -4 .. 4, colormap=:plasma,
        gridsize=(7, 7), arrow_size=0.25, linewidth=1)
    fig
end
arrows_and_streamplot_in_3d()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_arrows_and_streamplot_in_3d_.png" id="fig:arrows_and_streamplot_in_3d" style="width:60.0%" alt="Figure 42: Arrows and streamplot in 3d." /><figcaption aria-hidden="true">Figure 42: Arrows and streamplot in 3d.</figcaption>
</figure>
<p>Other interesting examples are a <code>mesh(obj)</code>, a <code>volume(x, y, z, vals)</code>, and a <code>contour(x, y, z, vals)</code>.</p>
<h3 data-number="5.7.4" id="meshes-and-volumes"><span class="header-section-number">5.7.4</span> Meshes and Volumes</h3>
<p>Drawing Meshes comes in handy when you want to plot geometries, like a <code>Sphere</code> or a Rectangle, i. e. <code>FRect3D</code>. Another approach to visualize points in 3D space is by calling the functions <code>volume</code> and <code>contour</code>, which implements <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray tracing</a> to simulate a wide variety of optical effects. See the next examples:</p>
<pre><code>using GeometryBasics</code></pre>
<pre class="language-julia"><code>function mesh_volume_contour()
    # mesh objects
    rectMesh = FRect3D(Vec3f(-0.5), Vec3f(1))
    recmesh = GeometryBasics.mesh(rectMesh)
    sphere = Sphere(Point3f(0), 1)
    # https://juliageometry.github.io/GeometryBasics.jl/stable/primitives/
    spheremesh = GeometryBasics.mesh(Tesselation(sphere, 64))
    # uses 64 for tesselation, a smoother sphere
    colors = [rand() for v in recmesh.position]
    # cloud points for volume
    x = y = z = 1:10
    vals = randn(10, 10, 10)
    fig = Figure(resolution=(1600, 400))
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1), perspectiveness=0.5) for i = 1:3]
    mesh!(axs[1], recmesh; color=colors, colormap=:rainbow, shading=false)
    mesh!(axs[1], spheremesh; color=(:white, 0.25), transparency=true)
    volume!(axs[2], x, y, z, vals; colormap=Reverse(:plasma))
    contour!(axs[3], x, y, z, vals; colormap=Reverse(:plasma))
    fig
end
mesh_volume_contour()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_mesh_volume_contour_.png" id="fig:mesh_volume_contour" alt="Figure 43: Mesh volume contour." /><figcaption aria-hidden="true">Figure 43: Mesh volume contour.</figcaption>
</figure>
<p>Note that here we are plotting two meshes in the same axis, one transparent sphere and a cube. So far, we have covered most of the 3D use-cases. Another example is <code>?linesegments</code>.</p>
<p>Taking as reference the previous example one can do the following custom plot with spheres and rectangles:</p>
<pre><code>using GeometryBasics, Colors</code></pre>
<p>For the spheres let’s do a rectangular grid. Also, we will use a different color for each one of them. Additionally, we can mix spheres and a rectangular plane. Next, we define all the necessary data.</p>
<pre class="language-julia"><code>seed!(123)
spheresGrid = [Point3f(i,j,k) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10]
colorSphere = [RGBA(i * 0.1, j * 0.1, k * 0.1, 0.75) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10]
spheresPlane = [Point3f(i,j,k) for i in 1:2.5:20 for j in 1:2.5:10 for k in 1:2.5:4]
cmap = get(colorschemes[:plasma], LinRange(0, 1, 50))
colorsPlane = cmap[rand(1:50,50)]
rectMesh = FRect3D(Vec3f(-1, -1, 2.1), Vec3f(22, 11, 0.5))
recmesh = GeometryBasics.mesh(rectMesh)
colors = [RGBA(rand(4)...) for v in recmesh.position]</code></pre>
<p>Then, the plot is simply done with:</p>
<pre class="language-julia"><code>function grid_spheres_and_rectangle_as_plate()
    fig = with_theme(theme_dark()) do
        fig = Figure(resolution=(1200, 800))
        ax1 = Axis3(fig[1, 1]; aspect=:data, perspectiveness=0.5, azimuth=0.72)
        ax2 = Axis3(fig[1, 2]; aspect=:data, perspectiveness=0.5)
        meshscatter!(ax1, spheresGrid; color = colorSphere, markersize = 1,
            shading=false)
        meshscatter!(ax2, spheresPlane; color=colorsPlane, markersize = 0.75,
            lightposition=Vec3f(10, 5, 2), ambient=Vec3f(0.95, 0.95, 0.95),
            backlight=1.0f0)
        mesh!(recmesh; color=colors, colormap=:rainbow, shading=false)
        limits!(ax1, 0, 10, 0, 10, 0, 10)
        fig
    end
    fig
end
grid_spheres_and_rectangle_as_plate()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_grid_spheres_and_rectangle_as_plate_.png" id="fig:grid_spheres_and_rectangle_as_plate" style="width:60.0%" alt="Figure 44: Grid spheres and rectangle as plate." /><figcaption aria-hidden="true">Figure 44: Grid spheres and rectangle as plate.</figcaption>
</figure>
<p>Here, the rectangle is semi-transparent due to the alpha channel added to the RGB color. The rectangle function is quite versatile, for instance 3D boxes are easy do implement which in turn could be used for plotting a 3D histogram. See our next example, where we are using again our <code>peaks</code> function and some additional definitions:</p>
<pre class="language-julia"><code>x, y, z = peaks(; n=15)
δx = (x[2] - x[1]) / 2
δy = (y[2] - y[1]) / 2
cbarPal = :Spectral_11
ztmp = (z .- minimum(z)) ./ (maximum(z .- minimum(z)))
cmap = get(colorschemes[cbarPal], ztmp)
cmap2 = reshape(cmap, size(z))
ztmp2 = abs.(z) ./ maximum(abs.(z)) .+ 0.15</code></pre>
<p>here <span class="math inline">\(\delta x, \delta y\)</span> are used to specified our boxes size. <code>cmap2</code> will be the color for each box and <code>ztmp2</code> will be used as a transparency parameter. See the output in the next figure.</p>
<pre class="language-julia"><code>function histogram_or_bars_in_3d()
    fig = Figure(resolution=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), elevation=π/6,
        perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    rectMesh = FRect3D(Vec3f0(-0.5, -0.5, 0), Vec3f0(1, 1, 1))
    meshscatter!(ax1, x, y, 0*z, marker = rectMesh, color = z[:],
        markersize = Vec3f.(2δx, 2δy, z[:]), colormap = :Spectral_11,
        shading=false)
    limits!(ax1, -3.5, 3.5, -3.5, 3.5, -7.45, 7.45)
    meshscatter!(ax2, x, y, 0*z, marker = rectMesh, color = z[:],
        markersize = Vec3f.(2δx, 2δy, z[:]), colormap = (:Spectral_11, 0.25),
        shading=false, transparency=true)
    for (idx, i) in enumerate(x), (idy, j) in enumerate(y)
        rectMesh = FRect3D(Vec3f(i - δx, j - δy, 0), Vec3f(2δx, 2δy, z[idx, idy]))
        recmesh = GeometryBasics.mesh(rectMesh)
        lines!(ax2, recmesh; color=(cmap2[idx, idy], ztmp2[idx, idy]))
    end
    fig
end
histogram_or_bars_in_3d()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_histogram_or_bars_in_3d_.png" id="fig:histogram_or_bars_in_3d" style="width:60.0%" alt="Figure 45: Histogram or bars in 3d." /><figcaption aria-hidden="true">Figure 45: Histogram or bars in 3d.</figcaption>
</figure>
<p>Note, that you can also call <code>lines</code> or <code>wireframe</code> over a mesh object.</p>
<h3 data-number="5.7.5" id="filled-line-and-band"><span class="header-section-number">5.7.5</span> Filled Line and Band</h3>
<p>For our last example we will show how to do a filled curve in 3D with <code>band</code> and some <code>linesegments</code>:</p>
<pre class="language-julia"><code>function filled_line_and_linesegments_in_3D()
    xs = LinRange(-3, 3, 10)
    lower = [Point3f(i, -i, 0) for i in LinRange(0, 3, 100)]
    upper = [Point3f(i, -i, sin(i) * exp(-(i + i))) for i in range(0, 3, length=100)]
    fig = Figure(resolution=(1200, 800))
    axs = [Axis3(fig[1, i]; elevation=pi/6, perspectiveness=0.5) for i = 1:2]
    band!(axs[1], lower, upper, color=repeat(norm.(upper), outer=2), colormap=:CMRmap)
    lines!(axs[1], upper, color=:black)
    linesegments!(axs[2], cos.(xs), xs, sin.(xs), linewidth=5, color=1:length(xs))
    fig
end
filled_line_and_linesegments_in_3D()</code></pre>
<figure>
<img src="JuliaDataScience/im/JDS_filled_line_and_linesegments_in_3D_.png" id="fig:filled_line_and_linesegments_in_3D" style="width:60.0%" alt="Figure 46: Filled line and linesegments in 3D." /><figcaption aria-hidden="true">Figure 46: Filled line and linesegments in 3D.</figcaption>
</figure>
<p>Finally, our journey doing 3D plots has come to an end. You can combine everything we exposed here to create amazing 3D images!</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="JuliaDataScience/makie_layouts"><b>5.6</b> Layouts</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="JuliaDataScience/appendix"><b>6</b> Appendix</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn18" role="doc-endnote"><p> 18. we are using the <code>LinearAlgebra</code> module from Julia’s standard library.<a href="JuliaDataScience#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>